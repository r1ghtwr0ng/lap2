searchNodes=[{"doc":"Example service provider for file transfer.","ref":"LAP2.Services.FileIO.html","title":"LAP2.Services.FileIO","type":"module"},{"doc":"","ref":"LAP2.Services.FileIO.html#handle_call/3","title":"LAP2.Services.FileIO.handle_call/3","type":"function"},{"doc":"Initialise the data handler GenServer.","ref":"LAP2.Services.FileIO.html#init/1","title":"LAP2.Services.FileIO.init/1","type":"function"},{"doc":"Parse a JSON request/response for a file and return the file contents.","ref":"LAP2.Services.FileIO.html#parse_cmd/2","title":"LAP2.Services.FileIO.parse_cmd/2","type":"function"},{"doc":"Request a file from a remote FileIO service. Provide a list of introduction points to the remote service.","ref":"LAP2.Services.FileIO.html#request_file/6","title":"LAP2.Services.FileIO.request_file/6","type":"function"},{"doc":"Register and start the File IO listener service.","ref":"LAP2.Services.FileIO.html#run_service/1","title":"LAP2.Services.FileIO.run_service/1","type":"function"},{"doc":"Start the Master process.","ref":"LAP2.Services.FileIO.html#start_link/1","title":"LAP2.Services.FileIO.start_link/1","type":"function"},{"doc":"Stop the service.","ref":"LAP2.Services.FileIO.html#stop_service/1","title":"LAP2.Services.FileIO.stop_service/1","type":"function"},{"doc":"Module for supervising the status of various network connections. Dispatches proxy requests via the ProxyManager. Encodes/decodes and routes data above the proxy abstraction layer. Receives commands directly from the Master module, interfaces with ProxyManager and IntroductionPoint modules. Relays are abstracted away by the ProxyManager, this module handles connections bound to proxy sequences.","ref":"LAP2.Main.ConnectionSupervisor.html","title":"LAP2.Main.ConnectionSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Main.ConnectionSupervisor.html#child_spec/1","title":"LAP2.Main.ConnectionSupervisor.child_spec/1","type":"function"},{"doc":"","ref":"LAP2.Main.ConnectionSupervisor.html#debug/1","title":"LAP2.Main.ConnectionSupervisor.debug/1","type":"function"},{"doc":"Deserialise and deliver an inbound Query to the appropriate route","ref":"LAP2.Main.ConnectionSupervisor.html#deliver_inbound/3","title":"LAP2.Main.ConnectionSupervisor.deliver_inbound/3","type":"function"},{"doc":"Attempt to establish a new anonymous proxy.","ref":"LAP2.Main.ConnectionSupervisor.html#establish_proxy/1","title":"LAP2.Main.ConnectionSupervisor.establish_proxy/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1 .","ref":"LAP2.Main.ConnectionSupervisor.html#init/1","title":"LAP2.Main.ConnectionSupervisor.init/1","type":"function"},{"doc":"Modify an existing connection to an introduction point.","ref":"LAP2.Main.ConnectionSupervisor.html#modify_connection/4","title":"LAP2.Main.ConnectionSupervisor.modify_connection/4","type":"function"},{"doc":"Proxy establishment successful, broadcast to listeners","ref":"LAP2.Main.ConnectionSupervisor.html#proxy_established/2","title":"LAP2.Main.ConnectionSupervisor.proxy_established/2","type":"function"},{"doc":"Removes a proxy connection from the ProxyManager and ConnectionSupervisor.","ref":"LAP2.Main.ConnectionSupervisor.html#remove_proxy/2","title":"LAP2.Main.ConnectionSupervisor.remove_proxy/2","type":"function"},{"doc":"Send an introduction point request to an existing connection. A list of service identifiers are passed in the request.","ref":"LAP2.Main.ConnectionSupervisor.html#request_introduction_point/2","title":"LAP2.Main.ConnectionSupervisor.request_introduction_point/2","type":"function"},{"doc":"","ref":"LAP2.Main.ConnectionSupervisor.html#request_introduction_point/3","title":"LAP2.Main.ConnectionSupervisor.request_introduction_point/3","type":"function"},{"doc":"Send a list of outbound queries via random connections.","ref":"LAP2.Main.ConnectionSupervisor.html#send_queries/2","title":"LAP2.Main.ConnectionSupervisor.send_queries/2","type":"function"},{"doc":"Send a query to an introduction point/host","ref":"LAP2.Main.ConnectionSupervisor.html#send_query/3","title":"LAP2.Main.ConnectionSupervisor.send_query/3","type":"function"},{"doc":"Send out a list of responses","ref":"LAP2.Main.ConnectionSupervisor.html#send_responses/2","title":"LAP2.Main.ConnectionSupervisor.send_responses/2","type":"function"},{"doc":"","ref":"LAP2.Main.ConnectionSupervisor.html#service_lookup/2","title":"LAP2.Main.ConnectionSupervisor.service_lookup/2","type":"function"},{"doc":"Start the ConnectionSupervisor process.","ref":"LAP2.Main.ConnectionSupervisor.html#start_link/1","title":"LAP2.Main.ConnectionSupervisor.start_link/1","type":"function"},{"doc":"Key rotation successful, broadcast to listeners","ref":"LAP2.Main.ConnectionSupervisor.html#successful_key_rotation/2","title":"LAP2.Main.ConnectionSupervisor.successful_key_rotation/2","type":"function"},{"doc":"Send an teardown request to an existing introduction point. Delete all associated state.","ref":"LAP2.Main.ConnectionSupervisor.html#teardown_introduction_point/2","title":"LAP2.Main.ConnectionSupervisor.teardown_introduction_point/2","type":"function"},{"doc":"Module for registering and routing various services over the network. Anonymous proxies and introduction points perform: Remote resource access Remote resource response Hidden hosts these provide: File transfer (upload/download) Any other request/response based service","ref":"LAP2.Main.ServiceProviders.html","title":"LAP2.Main.ServiceProviders","type":"module"},{"doc":"Route a query to the appropriate service provider.","ref":"LAP2.Main.ServiceProviders.html#route_query/3","title":"LAP2.Main.ServiceProviders.route_query/3","type":"function"},{"doc":"","ref":"LAP2.Main.ServiceProviders.html#route_tcp_query/3","title":"LAP2.Main.ServiceProviders.route_tcp_query/3","type":"function"},{"doc":"Acts as a buffer abstraction for service hosts. Uses ShareHandler to reconstruct original service requests. Provides utility functions for deconstructing responses to the appropriate requests.","ref":"LAP2.Main.Helpers.HostBuffer.html","title":"LAP2.Main.Helpers.HostBuffer","type":"module"},{"doc":"Disperse response data along the response list and send them back to the client.","ref":"LAP2.Main.Helpers.HostBuffer.html#disperse_response/3","title":"LAP2.Main.Helpers.HostBuffer.disperse_response/3","type":"function"},{"doc":"Attempt to reassemble a query from shares and send them to the appropriate service host.","ref":"LAP2.Main.Helpers.HostBuffer.html#reassemble_query/3","title":"LAP2.Main.Helpers.HostBuffer.reassemble_query/3","type":"function"},{"doc":"Send out requests for remote service data.","ref":"LAP2.Main.Helpers.HostBuffer.html#request_remote/5","title":"LAP2.Main.Helpers.HostBuffer.request_remote/5","type":"function"},{"doc":"Generates encoded JSON responses for listener processes.","ref":"LAP2.Main.Helpers.ListenerHandler.html","title":"LAP2.Main.Helpers.ListenerHandler","type":"module"},{"doc":"Send a JSON notification to the listener.","ref":"LAP2.Main.Helpers.ListenerHandler.html#broadcast/2","title":"LAP2.Main.Helpers.ListenerHandler.broadcast/2","type":"function"},{"doc":"Send a JSON query/response to the listener.","ref":"LAP2.Main.Helpers.ListenerHandler.html#deliver/5","title":"LAP2.Main.Helpers.ListenerHandler.deliver/5","type":"function"},{"doc":"Deliver a JSON command to a listener.","ref":"LAP2.Main.Helpers.ListenerHandler.html#deliver_to_listener/2","title":"LAP2.Main.Helpers.ListenerHandler.deliver_to_listener/2","type":"function"},{"doc":"","ref":"LAP2.Networking.Sockets.TcpServer.html","title":"LAP2.Networking.Sockets.TcpServer","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Networking.Sockets.TcpServer.html#child_spec/1","title":"LAP2.Networking.Sockets.TcpServer.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1 .","ref":"LAP2.Networking.Sockets.TcpServer.html#init/1","title":"LAP2.Networking.Sockets.TcpServer.init/1","type":"function"},{"doc":"","ref":"LAP2.Networking.Sockets.TcpServer.html#respond/3","title":"LAP2.Networking.Sockets.TcpServer.respond/3","type":"function"},{"doc":"","ref":"LAP2.Networking.Sockets.TcpServer.html#send/3","title":"LAP2.Networking.Sockets.TcpServer.send/3","type":"function"},{"doc":"Start the TCP server.","ref":"LAP2.Networking.Sockets.TcpServer.html#start_link/1","title":"LAP2.Networking.Sockets.TcpServer.start_link/1","type":"function"},{"doc":"Terminate the TCP server.","ref":"LAP2.Networking.Sockets.TcpServer.html#terminate/2","title":"LAP2.Networking.Sockets.TcpServer.terminate/2","type":"function"},{"doc":"This module is used to generate various secure tokens.","ref":"LAP2.Utils.Generator.html","title":"LAP2.Utils.Generator","type":"module"},{"doc":"Generate a random float value between two given values","ref":"LAP2.Utils.Generator.html#generate_float/2","title":"LAP2.Utils.Generator.generate_float/2","type":"function"},{"doc":"Generate a random hexadecimal string of a given byte length","ref":"LAP2.Utils.Generator.html#generate_hex/1","title":"LAP2.Utils.Generator.generate_hex/1","type":"function"},{"doc":"Generate a random non-negative integer value of a given byte length","ref":"LAP2.Utils.Generator.html#generate_integer/1","title":"LAP2.Utils.Generator.generate_integer/1","type":"function"},{"doc":"Contains helper functions for generating and parsing ProtoBuf Query structs","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html","title":"LAP2.Utils.ProtoBuf.QueryHelper","type":"module"},{"doc":"Build a content request header","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_content_request_header/1","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_content_request_header/1","type":"function"},{"doc":"Build a DHT request header Currently not fully implemented","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_dht_request_header/0","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_dht_request_header/0","type":"function"},{"doc":"Build an introduction point establishment header","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_establish_header/1","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_establish_header/1","type":"function"},{"doc":"Build an outgoing query struct","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_query/3","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_query/3","type":"function"},{"doc":"Build a remote query header","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_remote_query_header/3","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_remote_query_header/3","type":"function"},{"doc":"Set the ACK flag and replace the data with the response","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_response/2","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_response/2","type":"function"},{"doc":"Build an introduction point teardown header","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#build_teardown_header/0","title":"LAP2.Utils.ProtoBuf.QueryHelper.build_teardown_header/0","type":"function"},{"doc":"Deserialise a Query struct","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#deserialise/1","title":"LAP2.Utils.ProtoBuf.QueryHelper.deserialise/1","type":"function"},{"doc":"Serialise a Query struct","ref":"LAP2.Utils.ProtoBuf.QueryHelper.html#serialise/1","title":"LAP2.Utils.ProtoBuf.QueryHelper.serialise/1","type":"function"},{"doc":"Module for managing the state of cryptographic information for proxy connections.","ref":"LAP2.Crypto.CryptoManager.html","title":"LAP2.Crypto.CryptoManager","type":"module"},{"doc":"Add a crypto struct to the ETS table. TODO this is for testing ONLY, remove for final version (as well as its genserver call)","ref":"LAP2.Crypto.CryptoManager.html#add_crypto_struct/3","title":"LAP2.Crypto.CryptoManager.add_crypto_struct/3","type":"function"},{"doc":"Add a temporary crypto struct to the state.","ref":"LAP2.Crypto.CryptoManager.html#add_temp_crypto_struct/3","title":"LAP2.Crypto.CryptoManager.add_temp_crypto_struct/3","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Crypto.CryptoManager.html#child_spec/1","title":"LAP2.Crypto.CryptoManager.child_spec/1","type":"function"},{"doc":"","ref":"LAP2.Crypto.CryptoManager.html#debug_crypto_structs/1","title":"LAP2.Crypto.CryptoManager.debug_crypto_structs/1","type":"function"},{"doc":"Decrypt a request using the key stored in the ETS table. Return binary for deserialisation.","ref":"LAP2.Crypto.CryptoManager.html#decrypt_request/3","title":"LAP2.Crypto.CryptoManager.decrypt_request/3","type":"function"},{"doc":"Delete a temporary crypto struct from the state.","ref":"LAP2.Crypto.CryptoManager.html#delete_temp_crypto/2","title":"LAP2.Crypto.CryptoManager.delete_temp_crypto/2","type":"function"},{"doc":"Encrypt a serialised (binary) request, returning an EncryptedRequest struct.","ref":"LAP2.Crypto.CryptoManager.html#encrypt_request/3","title":"LAP2.Crypto.CryptoManager.encrypt_request/3","type":"function"},{"doc":"","ref":"LAP2.Crypto.CryptoManager.html#get_crypto_struct/2","title":"LAP2.Crypto.CryptoManager.get_crypto_struct/2","type":"function"},{"doc":"Fetch the crypto identity from the GenServer state.","ref":"LAP2.Crypto.CryptoManager.html#get_identity/1","title":"LAP2.Crypto.CryptoManager.get_identity/1","type":"function"},{"doc":"Get a temporary crypto struct from the state.","ref":"LAP2.Crypto.CryptoManager.html#get_temp_crypto_struct/2","title":"LAP2.Crypto.CryptoManager.get_temp_crypto_struct/2","type":"function"},{"doc":"Initialise the data handler GenServer.","ref":"LAP2.Crypto.CryptoManager.html#init/1","title":"LAP2.Crypto.CryptoManager.init/1","type":"function"},{"doc":"Remove a crypto struct from the ETS table.","ref":"LAP2.Crypto.CryptoManager.html#remove_crypto_struct/2","title":"LAP2.Crypto.CryptoManager.remove_crypto_struct/2","type":"function"},{"doc":"Perform key rotation request with a remote proxy.","ref":"LAP2.Crypto.CryptoManager.html#rotate_keys/3","title":"LAP2.Crypto.CryptoManager.rotate_keys/3","type":"function"},{"doc":"Start the CryptoManager process.","ref":"LAP2.Crypto.CryptoManager.html#start_link/1","title":"LAP2.Crypto.CryptoManager.start_link/1","type":"function"},{"doc":"This module implements a Claimable Ring Signature (CRS) scheme. The scheme allows a member to claim their signature after the fact by revealing a commitment secret. This encryption scheme is based on the specification from the following paper: Park, S. and Sealfon, A., 2019. It wasn’t me! Repudiability and claimability of ring signatures. In Advances in Cryptology–CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18–22, 2019, Proceedings, Part III 39 (pp. 159-190). Springer International Publishing.","ref":"LAP2.Crypto.Constructions.ClaimableRS.html","title":"LAP2.Crypto.Constructions.ClaimableRS","type":"module"},{"doc":"Generate a claim for a C-RS signature. Arguments ring_idx - The positional index of the signer in the ring (secret). sk - The C-RS secret key tuple. sag - The C-RS signature (SAG.t()). Returns {:ok, claim} - The C-RS claim ({commitment, signature}). {:error, reason} - The reason for failure.","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#crs_claim/3","title":"LAP2.Crypto.Constructions.ClaimableRS.crs_claim/3","type":"function"},{"doc":"Generate a Claimable RS (C-RS) key pair. Returns a map with the secret and verification keys (sk, vk) respectively.","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#crs_gen/0","title":"LAP2.Crypto.Constructions.ClaimableRS.crs_gen/0","type":"function"},{"doc":"Generate a C-RS signature. Arguments ring_idx - The positional index of the signer in the ring (secret). sk - The C-RS secret key tuple. ring - The ring of verification (public) keys. msg - The message to sign (charlist). Returns {:ok, signature} - The C-RS signature. {:error, reason} - The reason for failure.","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#crs_sign/4","title":"LAP2.Crypto.Constructions.ClaimableRS.crs_sign/4","type":"function"},{"doc":"Verify a C-RS signature. Arguments sag - The C-RS signature (SAG.t()). msg - The message to verify (charlist).","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#crs_vrfy/2","title":"LAP2.Crypto.Constructions.ClaimableRS.crs_vrfy/2","type":"function"},{"doc":"Verify the validity of a claim for a C-RS signature. Arguments vk - The C-RS verification (public) key. sag - The C-RS signature (SAG.t()). claim - The C-RS claim ({commitment, signature}).","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#crs_vrfy_claim/3","title":"LAP2.Crypto.Constructions.ClaimableRS.crs_vrfy_claim/3","type":"function"},{"doc":"Generate a secret and public key pair tuple for a Claimable Ring Signature (CRS) scheme.","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#rs_gen/0","title":"LAP2.Crypto.Constructions.ClaimableRS.rs_gen/0","type":"function"},{"doc":"Generate an SAG ring signature for a message. This function verifies the validity of the arguments before calling the Rust NIF. Arguments ring_idx - The index of the ring member in the ring sk - The secret key of the ring member ring - The ring of public keys msg - The message to sign Returns {:ok, sig} if the arguments are valid, {:error, reason} otherwise","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#rs_sign/4","title":"LAP2.Crypto.Constructions.ClaimableRS.rs_sign/4","type":"function"},{"doc":"Verify an SAG ring signature for a message. Arguments sag - The SAG ring signature msg - The message to verify Returns {:ok, true} if the signature is valid, {:ok, false} otherwise {:error, reason} if the arguments are invalid","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#rs_vrfy/2","title":"LAP2.Crypto.Constructions.ClaimableRS.rs_vrfy/2","type":"function"},{"doc":"Merge a SAG struct to a flat charlist. Arguments sag - The SAG struct. Returns charlist - The flattened SAG struct.","ref":"LAP2.Crypto.Constructions.ClaimableRS.html#sag_to_charlist/1","title":"LAP2.Crypto.Constructions.ClaimableRS.sag_to_charlist/1","type":"function"},{"doc":"","ref":"LAP2.Crypto.Constructions.CryptoNifs.html","title":"LAP2.Crypto.Constructions.CryptoNifs","type":"module"},{"doc":"Generate a hash-based (SHA256) commitment of a message. Arguments sk - Secret commitment key (charlist) rand - The randomness used to generate the commitment (charlist) Returns The commitment (charlist)","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#commit_gen/2","title":"LAP2.Crypto.Constructions.CryptoNifs.commit_gen/2","type":"function"},{"doc":"Verify a hash-based (SHA256) commitment. Arguments sk - Secret commitment key (charlist) rand - The randomness used to generate the commitment (charlist) com - The commitment to verify (charlist) Returns true if the commitment is valid, false otherwise","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#commit_vrfy/3","title":"LAP2.Crypto.Constructions.CryptoNifs.commit_vrfy/3","type":"function"},{"doc":"Generate pseudo-random function (PRF) output. The PRF uses AES128-CMAC. Arguments sk - Secret PRF key (charlist) data - The data to be used as a random seed (charlist) Returns The PRF output (charlist)","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#prf_eval/2","title":"LAP2.Crypto.Constructions.CryptoNifs.prf_eval/2","type":"function"},{"doc":"Generate n-bit randomness (floored to nearest byte). Arguments n - The number of bits of randomness to generate Returns The generated randomness (charlist)","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#prf_gen/1","title":"LAP2.Crypto.Constructions.CryptoNifs.prf_gen/1","type":"function"},{"doc":"Generate a secret and public key pair tuple for a Spontaneous Anonymous Group (SAG) ring signature scheme. Returns A tuple containing the secret and public keys (charlist, charlist)","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#rs_nif_gen/0","title":"LAP2.Crypto.Constructions.CryptoNifs.rs_nif_gen/0","type":"function"},{"doc":"Sign a message using a Spontaneous Anonymous Group (SAG) ring signature. Arguments idx - The index of the signer in the ring (non-negative integer) sk - The signer's secret key (charlist) ring - The ring of public keys (list of charlists) msg - The message to be signed (charlist) Returns A ring signature tuple containing the signature challenge, response, and ring (charlist, list(charlist), list(charlist))","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#rs_nif_sign/4","title":"LAP2.Crypto.Constructions.CryptoNifs.rs_nif_sign/4","type":"function"},{"doc":"Verify a Spontaneous Anonymous Group (SAG) ring signature. Arguments chal - The signature challenge (charlist) ring - The ring of public keys (list of charlists) resp - The challenge responses (list of charlists) msg - The message that was signed (charlist) Returns true if the signature is valid, false otherwise","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#rs_nif_vrfy/4","title":"LAP2.Crypto.Constructions.CryptoNifs.rs_nif_vrfy/4","type":"function"},{"doc":"Generate a secret and public key pair tuple for a RSA-PSS signature scheme. Returns A tuple containing the secret and public keys (charlist, charlist)","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#standard_signature_gen/0","title":"LAP2.Crypto.Constructions.CryptoNifs.standard_signature_gen/0","type":"function"},{"doc":"Sign a message using the RSA-PSS probabilistic signature scheme. Arguments sk - The signer's secret key (charlist) msg - The message to be signed (charlist) rand - The randomness used to generate the signature (charlist) Returns The signature (charlist)","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#standard_signature_sign/3","title":"LAP2.Crypto.Constructions.CryptoNifs.standard_signature_sign/3","type":"function"},{"doc":"Verify a RSA-PSS signature. Arguments sig - The signature to verify (charlist) vk - The signer's public key (charlist) msg - The message to be signed (charlist) Returns true if the signature is valid, false otherwise","ref":"LAP2.Crypto.Constructions.CryptoNifs.html#standard_signature_vrfy/3","title":"LAP2.Crypto.Constructions.CryptoNifs.standard_signature_vrfy/3","type":"function"},{"doc":"Contains helper functions for various cryptographic ops","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html","title":"LAP2.Crypto.Helpers.CryptoStructHelper","type":"module"},{"doc":"Generate key rotation acknowledgement response (EncryptedRequest struct)","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#ack_key_rotation/3","title":"LAP2.Crypto.Helpers.CryptoStructHelper.ack_key_rotation/3","type":"function"},{"doc":"Verify the validity of the HMAC","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#check_hmac/1","title":"LAP2.Crypto.Helpers.CryptoStructHelper.check_hmac/1","type":"function"},{"doc":"Generate final key exchange primitives and response (EncryptedRequest struct)","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#gen_fin_crypto/3","title":"LAP2.Crypto.Helpers.CryptoStructHelper.gen_fin_crypto/3","type":"function"},{"doc":"Generate initial key exchange primitives and response (EncryptedRequest struct)","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#gen_init_crypto/2","title":"LAP2.Crypto.Helpers.CryptoStructHelper.gen_init_crypto/2","type":"function"},{"doc":"Generate key rotation primitives and response (EncryptedRequest struct)","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#gen_key_rotation/2","title":"LAP2.Crypto.Helpers.CryptoStructHelper.gen_key_rotation/2","type":"function"},{"doc":"","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#gen_request/5","title":"LAP2.Crypto.Helpers.CryptoStructHelper.gen_request/5","type":"function"},{"doc":"","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#gen_resp_crypto/2","title":"LAP2.Crypto.Helpers.CryptoStructHelper.gen_resp_crypto/2","type":"function"},{"doc":"Generate key exchange response primitives and response (EncryptedRequest struct)","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#gen_resp_crypto/3","title":"LAP2.Crypto.Helpers.CryptoStructHelper.gen_resp_crypto/3","type":"function"},{"doc":"Generate key, calculate HMAC and set appropriate Request fields","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#set_hmac/1","title":"LAP2.Crypto.Helpers.CryptoStructHelper.set_hmac/1","type":"function"},{"doc":"Verify the validity of the ring signature","ref":"LAP2.Crypto.Helpers.CryptoStructHelper.html#verify_ring_signature/3","title":"LAP2.Crypto.Helpers.CryptoStructHelper.verify_ring_signature/3","type":"function"},{"doc":"Rabin's Information Dispersal Algorithm, used to split and reconstruct data.","ref":"LAP2.Crypto.InformationDispersal.RabinIDA.html","title":"LAP2.Crypto.InformationDispersal.RabinIDA","type":"module"},{"doc":"","ref":"LAP2.Crypto.InformationDispersal.RabinIDA.html#decode_double_byte/1","title":"LAP2.Crypto.InformationDispersal.RabinIDA.decode_double_byte/1","type":"function"},{"doc":"","ref":"LAP2.Crypto.InformationDispersal.RabinIDA.html#encode_double_byte/1","title":"LAP2.Crypto.InformationDispersal.RabinIDA.encode_double_byte/1","type":"function"},{"doc":"Reconstruct the data from the given shares. Generates the reassembly matrix and performs matrix multiplication with the data in the shares. Finally, the data is un-padded and returned. Arguments shares - The shares to reconstruct the data from (list(map)) Returns {:ok, binary} - The reconstructed data {:error, nil} - The shares are not enough to reconstruct the data","ref":"LAP2.Crypto.InformationDispersal.RabinIDA.html#reconstruct/1","title":"LAP2.Crypto.InformationDispersal.RabinIDA.reconstruct/1","type":"function"},{"doc":"Split the data into the given number of shares. Arguments data - The data to split (binary) n - The number of shares to generate (non-negative integer) m - The size of each share (non-negative integer) Returns A list of shares, each containing the share data and its index (list(map))","ref":"LAP2.Crypto.InformationDispersal.RabinIDA.html#split/3","title":"LAP2.Crypto.InformationDispersal.RabinIDA.split/3","type":"function"},{"doc":"Security enhanced Information Dispersal Algorithm, used to split and reconstruct data. TODO actually make it use a proper IDA rather than splitting the data lol","ref":"LAP2.Crypto.InformationDispersal.SecureIDA.html","title":"LAP2.Crypto.InformationDispersal.SecureIDA","type":"module"},{"doc":"Encrypt and split the data into the given number of shares. Encryption keys are split using Shamir's secret sharing, while the data is split using Rabin's IDA. Arguments data - The data to split (binary) n - The number of shares to generate (non-negative integer) m - The size of each share (non-negative integer), also the reconstruction threshold Returns A list of shares, each containing the share data and its index (list(Share.t()))","ref":"LAP2.Crypto.InformationDispersal.SecureIDA.html#disperse/4","title":"LAP2.Crypto.InformationDispersal.SecureIDA.disperse/4","type":"function"},{"doc":"Reconstruct the original data from the given shares. Arguments shares - The shares to reconstruct the data from (list(Share.t())) Returns {:ok, data} - The reconstructed data (binary) {:error, reason} - The reason why the data could not be reconstructed (binary)","ref":"LAP2.Crypto.InformationDispersal.SecureIDA.html#reconstruct/1","title":"LAP2.Crypto.InformationDispersal.SecureIDA.reconstruct/1","type":"function"},{"doc":"This module implements the C-RSDAKE key exchange protocol. See:","ref":"LAP2.Crypto.KeyExchange.C_RSDAKE.html","title":"LAP2.Crypto.KeyExchange.C_RSDAKE","type":"module"},{"doc":"Implements RSDAKE's finalisation phase. Arguments identity - The identity of the responder (charlist) sk_lt - The long-term secret key of the responder (map) recv_resp - The response received from the other party (KeyExchangeResponse.t() Returns }} {:error, :invalid_arguments} {:error, :invalid_signature} {:error, :invalid_identity} {:error, :invalid_ring_signature}","ref":"LAP2.Crypto.KeyExchange.C_RSDAKE.html#finalise/3","title":"LAP2.Crypto.KeyExchange.C_RSDAKE.finalise/3","type":"function"},{"doc":"Implements RSDAKE's key exchange protocol initialisation phase. Arguments identity - The identity of the initiator (charlist) Returns {:ok, {crypto_state, init_struct}} - The initialisation message and the new crypto state {:error, :invalid_identity} - The identity is invalid","ref":"LAP2.Crypto.KeyExchange.C_RSDAKE.html#initialise/1","title":"LAP2.Crypto.KeyExchange.C_RSDAKE.initialise/1","type":"function"},{"doc":"Implements RSDAKE's response phase. Parameters identity - The identity of the responder (charlist) sk_lt - The long-term secret key of the responder (map) recv_init - The received initialisation message (KeyExchangeInit.t()) Returns {:ok, {crypto_state, response_struct}} - The response message and the new crypto state {:error, :invalid_aguments} - The identity is invalid {:error, :invalid_signature} - The signature is invalid","ref":"LAP2.Crypto.KeyExchange.C_RSDAKE.html#respond/3","title":"LAP2.Crypto.KeyExchange.C_RSDAKE.respond/3","type":"function"},{"doc":"Implements RSDAKE's final response verification phase. Arguments identity - The identity of the responder (charlist) crypto_state - The crypto state of the responder (map) recv_resp - The response received from the other party (KeyExchangeResponse.t() Returns {:error, :invalid_arguments} {:error, :invalid_ring_signature}","ref":"LAP2.Crypto.KeyExchange.C_RSDAKE.html#verify_final/3","title":"LAP2.Crypto.KeyExchange.C_RSDAKE.verify_final/3","type":"function"},{"doc":"","ref":"LAP2.Crypto.KeyExchange.C_RSDAKE.html#t:crypto_state/0","title":"LAP2.Crypto.KeyExchange.C_RSDAKE.crypto_state/0","type":"type"},{"doc":"This module implements the RSDAKE key exchange protocol. TODO consider depricating this and just use C-RSDAKE. If the user doesn't wish to have claimability, they can just discard the PRF secret and RS commitments.","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html","title":"LAP2.Crypto.KeyExchange.RSDAKE","type":"module"},{"doc":"Implements RSDAKE's finalisation phase.","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#finalise/3","title":"LAP2.Crypto.KeyExchange.RSDAKE.finalise/3","type":"function"},{"doc":"Implements RSDAKE's key exchange protocol initialisation phase.","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#initialise/1","title":"LAP2.Crypto.KeyExchange.RSDAKE.initialise/1","type":"function"},{"doc":"Implements RSDAKE's response phase.","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#respond/3","title":"LAP2.Crypto.KeyExchange.RSDAKE.respond/3","type":"function"},{"doc":"Implements RSDAKE's final response verification phase.","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#verify_final/3","title":"LAP2.Crypto.KeyExchange.RSDAKE.verify_final/3","type":"function"},{"doc":"","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#t:crypto_state/0","title":"LAP2.Crypto.KeyExchange.RSDAKE.crypto_state/0","type":"type"},{"doc":"","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#t:rsdake_final/0","title":"LAP2.Crypto.KeyExchange.RSDAKE.rsdake_final/0","type":"type"},{"doc":"","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#t:rsdake_init/0","title":"LAP2.Crypto.KeyExchange.RSDAKE.rsdake_init/0","type":"type"},{"doc":"","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#t:rsdake_resp/0","title":"LAP2.Crypto.KeyExchange.RSDAKE.rsdake_resp/0","type":"type"},{"doc":"","ref":"LAP2.Crypto.KeyExchange.RSDAKE.html#t:sag/0","title":"LAP2.Crypto.KeyExchange.RSDAKE.sag/0","type":"type"},{"doc":"PKCS7 padding and unpadding.","ref":"LAP2.Crypto.Padding.PKCS7.html","title":"LAP2.Crypto.Padding.PKCS7","type":"module"},{"doc":"Pad the given data to the block size of 16.","ref":"LAP2.Crypto.Padding.PKCS7.html#pad/2","title":"LAP2.Crypto.Padding.PKCS7.pad/2","type":"function"},{"doc":"Unpad the given data.","ref":"LAP2.Crypto.Padding.PKCS7.html#unpad/1","title":"LAP2.Crypto.Padding.PKCS7.unpad/1","type":"function"},{"doc":"ProtoBuf serialisation and deserialisation.","ref":"LAP2.Networking.ProtoBuf.html","title":"LAP2.Networking.ProtoBuf","type":"module"},{"doc":"Deserialised received data","ref":"LAP2.Networking.ProtoBuf.html#deserialise/2","title":"LAP2.Networking.ProtoBuf.deserialise/2","type":"function"},{"doc":"Serialise a map via ProtoBuff before sending it","ref":"LAP2.Networking.ProtoBuf.html#serialise/1","title":"LAP2.Networking.ProtoBuf.serialise/1","type":"function"},{"doc":"This module contains helper function for resolving addresses.","ref":"LAP2.Networking.Resolver.html","title":"LAP2.Networking.Resolver","type":"module"},{"doc":"Build a DHT update query","ref":"LAP2.Networking.Resolver.html#build_dht_query/0","title":"LAP2.Networking.Resolver.build_dht_query/0","type":"function"},{"doc":"Fetch the DHT from the router","ref":"LAP2.Networking.Resolver.html#distribute_dht/2","title":"LAP2.Networking.Resolver.distribute_dht/2","type":"function"},{"doc":"","ref":"LAP2.Networking.Resolver.html#resolve_addr/2","title":"LAP2.Networking.Resolver.resolve_addr/2","type":"function"},{"doc":"Update the DHT in the router","ref":"LAP2.Networking.Resolver.html#update_dht/2","title":"LAP2.Networking.Resolver.update_dht/2","type":"function"},{"doc":"Stores routing information, updates DHT and stores information for resolving addresses. The actual functions for resolving the addresses, extracting keys, etc. is located in LAP2.Networking.Resolver This module also stores connection information (anonymous paths and corresponidng crypto keys) TODO have a look at a secure way of storing the keys","ref":"LAP2.Networking.Router.html","title":"LAP2.Networking.Router","type":"module"},{"doc":"Accept and reply to a proxy request, update state accordingly.","ref":"LAP2.Networking.Router.html#add_proxy_relays/3","title":"LAP2.Networking.Router.add_proxy_relays/3","type":"function"},{"doc":"Update the DHT with a new entry in the state","ref":"LAP2.Networking.Router.html#append_dht/3","title":"LAP2.Networking.Router.append_dht/3","type":"function"},{"doc":"Cache an inbound TCP query so it can be used in the response. This is a used by Introduction Points.","ref":"LAP2.Networking.Router.html#cache_query/4","title":"LAP2.Networking.Router.cache_query/4","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Networking.Router.html#child_spec/1","title":"LAP2.Networking.Router.child_spec/1","type":"function"},{"doc":"Delete outdated entries from state.","ref":"LAP2.Networking.Router.html#clean_state/1","title":"LAP2.Networking.Router.clean_state/1","type":"function"},{"doc":"Inspect the router state.","ref":"LAP2.Networking.Router.html#debug/1","title":"LAP2.Networking.Router.debug/1","type":"function"},{"doc":"","ref":"LAP2.Networking.Router.html#drop_test/2","title":"LAP2.Networking.Router.drop_test/2","type":"function"},{"doc":"Attempt to fetch a cached query from the router's cache. If retrieved, it is deleted from the cache to conserve memory.","ref":"LAP2.Networking.Router.html#get_cached_query/2","title":"LAP2.Networking.Router.get_cached_query/2","type":"function"},{"doc":"Get the DHT from the state","ref":"LAP2.Networking.Router.html#get_dht/1","title":"LAP2.Networking.Router.get_dht/1","type":"function"},{"doc":"Get a list of neighbors from the state","ref":"LAP2.Networking.Router.html#get_neighbors/1","title":"LAP2.Networking.Router.get_neighbors/1","type":"function"},{"doc":"Retrieve the origin proxy sequence number for a given query ID.","ref":"LAP2.Networking.Router.html#get_query_relay/2","title":"LAP2.Networking.Router.get_query_relay/2","type":"function"},{"doc":"Initialise the router.","ref":"LAP2.Networking.Router.html#init/1","title":"LAP2.Networking.Router.init/1","type":"function"},{"doc":"Route an inbound clove to the appropriate destination.","ref":"LAP2.Networking.Router.html#route_inbound/3","title":"LAP2.Networking.Router.route_inbound/3","type":"function"},{"doc":"Route data to the appropriate destination.","ref":"LAP2.Networking.Router.html#route_outbound/3","title":"LAP2.Networking.Router.route_outbound/3","type":"function"},{"doc":"","ref":"LAP2.Networking.Router.html#route_outbound_discovery/3","title":"LAP2.Networking.Router.route_outbound_discovery/3","type":"function"},{"doc":"","ref":"LAP2.Networking.Router.html#route_tcp/2","title":"LAP2.Networking.Router.route_tcp/2","type":"function"},{"doc":"Save the origin relay sequence number for a given query ID. This is done so responses can be routed back to the requesting node.","ref":"LAP2.Networking.Router.html#save_query_relay/3","title":"LAP2.Networking.Router.save_query_relay/3","type":"function"},{"doc":"Start the Router process.","ref":"LAP2.Networking.Router.html#start_link/1","title":"LAP2.Networking.Router.start_link/1","type":"function"},{"doc":"Terminate the UDP server.","ref":"LAP2.Networking.Router.html#terminate/2","title":"LAP2.Networking.Router.terminate/2","type":"function"},{"doc":"Update the configuration in the state","ref":"LAP2.Networking.Router.html#update_config/2","title":"LAP2.Networking.Router.update_config/2","type":"function"},{"doc":"Contains outbound pipelines for dispersing and sending requests and responses.","ref":"LAP2.Networking.Helpers.OutboundPipelines.html","title":"LAP2.Networking.Helpers.OutboundPipelines","type":"module"},{"doc":"Disperse and send out a proxy request acknowledgement.","ref":"LAP2.Networking.Helpers.OutboundPipelines.html#send_proxy_accept/5","title":"LAP2.Networking.Helpers.OutboundPipelines.send_proxy_accept/5","type":"function"},{"doc":"Disperse and cast out proxy discovery requests.","ref":"LAP2.Networking.Helpers.OutboundPipelines.html#send_proxy_discovery/5","title":"LAP2.Networking.Helpers.OutboundPipelines.send_proxy_discovery/5","type":"function"},{"doc":"Send out data to a proxy via anonymous routes.","ref":"LAP2.Networking.Helpers.OutboundPipelines.html#send_regular_request/4","title":"LAP2.Networking.Helpers.OutboundPipelines.send_regular_request/4","type":"function"},{"doc":"Contains functions for splitting up data into shares, then sending them via the appropriate relays.","ref":"LAP2.Networking.Helpers.RelaySelector.html","title":"LAP2.Networking.Helpers.RelaySelector","type":"module"},{"doc":"Select several random neighbors via which to cast proxy discovery cloves.","ref":"LAP2.Networking.Helpers.RelaySelector.html#cast_proxy_discovery/5","title":"LAP2.Networking.Helpers.RelaySelector.cast_proxy_discovery/5","type":"function"},{"doc":"Disperse the provided data and send it via the appropriate relays to the desired proxy.","ref":"LAP2.Networking.Helpers.RelaySelector.html#disperse_and_send/5","title":"LAP2.Networking.Helpers.RelaySelector.disperse_and_send/5","type":"function"},{"doc":"Module for managing the state of the routing module.","ref":"LAP2.Networking.Helpers.State.html","title":"LAP2.Networking.Helpers.State","type":"module"},{"doc":"Add clove to list of own cloves.","ref":"LAP2.Networking.Helpers.State.html#add_own_clove/2","title":"LAP2.Networking.Helpers.State.add_own_clove/2","type":"function"},{"doc":"Add entry to relay table","ref":"LAP2.Networking.Helpers.State.html#add_proxy_relay/3","title":"LAP2.Networking.Helpers.State.add_proxy_relay/3","type":"function"},{"doc":"","ref":"LAP2.Networking.Helpers.State.html#add_query_relay/3","title":"LAP2.Networking.Helpers.State.add_query_relay/3","type":"function"},{"doc":"","ref":"LAP2.Networking.Helpers.State.html#add_relay/4","title":"LAP2.Networking.Helpers.State.add_relay/4","type":"function"},{"doc":"Add a drop rule for the clove_Seq.","ref":"LAP2.Networking.Helpers.State.html#ban_clove/2","title":"LAP2.Networking.Helpers.State.ban_clove/2","type":"function"},{"doc":"Add a clove to the local cache.","ref":"LAP2.Networking.Helpers.State.html#cache_clove/4","title":"LAP2.Networking.Helpers.State.cache_clove/4","type":"function"},{"doc":"Remove outdated entries from the state based on their timestamps.","ref":"LAP2.Networking.Helpers.State.html#clean_state/1","title":"LAP2.Networking.Helpers.State.clean_state/1","type":"function"},{"doc":"Remove a clove from the list of own cloves.","ref":"LAP2.Networking.Helpers.State.html#delete_own_clove/2","title":"LAP2.Networking.Helpers.State.delete_own_clove/2","type":"function"},{"doc":"Evict a clove from the cache.","ref":"LAP2.Networking.Helpers.State.html#evict_clove/2","title":"LAP2.Networking.Helpers.State.evict_clove/2","type":"function"},{"doc":"Get routing information from state","ref":"LAP2.Networking.Helpers.State.html#get_route/3","title":"LAP2.Networking.Helpers.State.get_route/3","type":"function"},{"doc":"Remove a neighbor from the list of random neighbors.","ref":"LAP2.Networking.Helpers.State.html#remove_neighbor/2","title":"LAP2.Networking.Helpers.State.remove_neighbor/2","type":"function"},{"doc":"Update the cache entry timestamp.","ref":"LAP2.Networking.Helpers.State.html#update_clove_timestamp/2","title":"LAP2.Networking.Helpers.State.update_clove_timestamp/2","type":"function"},{"doc":"Update the relay table entry timestamp.","ref":"LAP2.Networking.Helpers.State.html#update_relay_timestamp/2","title":"LAP2.Networking.Helpers.State.update_relay_timestamp/2","type":"function"},{"doc":"Module for routing cloves to the local share handler.","ref":"LAP2.Networking.Routing.Local.html","title":"LAP2.Networking.Routing.Local","type":"module"},{"doc":"Handle a proxy request from a remote node.","ref":"LAP2.Networking.Routing.Local.html#handle_proxy_request/3","title":"LAP2.Networking.Routing.Local.handle_proxy_request/3","type":"function"},{"doc":"Handle a discovery response from a remote node.","ref":"LAP2.Networking.Routing.Local.html#receive_discovery_response/3","title":"LAP2.Networking.Routing.Local.receive_discovery_response/3","type":"function"},{"doc":"Relay a clove to the local share handler.","ref":"LAP2.Networking.Routing.Local.html#relay_clove/2","title":"LAP2.Networking.Routing.Local.relay_clove/2","type":"function"},{"doc":"Module for routing cloves to remote destinations.","ref":"LAP2.Networking.Routing.Remote.html","title":"LAP2.Networking.Routing.Remote","type":"module"},{"doc":"Relay a proxy request along its path.","ref":"LAP2.Networking.Routing.Remote.html#relay_clove/3","title":"LAP2.Networking.Routing.Remote.relay_clove/3","type":"function"},{"doc":"Route a discovery response along its path.","ref":"LAP2.Networking.Routing.Remote.html#relay_discovery_response/4","title":"LAP2.Networking.Routing.Remote.relay_discovery_response/4","type":"function"},{"doc":"Relay a proxy discovery clove to a random neighbour.","ref":"LAP2.Networking.Routing.Remote.html#relay_proxy_discovery/4","title":"LAP2.Networking.Routing.Remote.relay_proxy_discovery/4","type":"function"},{"doc":"Route a clove to a remote destination.","ref":"LAP2.Networking.Routing.Remote.html#route_outbound/3","title":"LAP2.Networking.Routing.Remote.route_outbound/3","type":"function"},{"doc":"Route a clove to a remote destination.","ref":"LAP2.Networking.Routing.Remote.html#route_outbound_discovery/3","title":"LAP2.Networking.Routing.Remote.route_outbound_discovery/3","type":"function"},{"doc":"Module for serialising/deserialising ProtoBuf cloves and sending/receiving them over UDP.","ref":"LAP2.Networking.Sockets.Lap2Socket.html","title":"LAP2.Networking.Sockets.Lap2Socket","type":"module"},{"doc":"Parse a received datagram.","ref":"LAP2.Networking.Sockets.Lap2Socket.html#parse_dgram/3","title":"LAP2.Networking.Sockets.Lap2Socket.parse_dgram/3","type":"function"},{"doc":"Parse a received TCP segment.","ref":"LAP2.Networking.Sockets.Lap2Socket.html#parse_segment/3","title":"LAP2.Networking.Sockets.Lap2Socket.parse_segment/3","type":"function"},{"doc":"Reply to a TCP request with a response Query.","ref":"LAP2.Networking.Sockets.Lap2Socket.html#respond_tcp/3","title":"LAP2.Networking.Sockets.Lap2Socket.respond_tcp/3","type":"function"},{"doc":"Send a clove to a destination address and port.","ref":"LAP2.Networking.Sockets.Lap2Socket.html#send_clove/3","title":"LAP2.Networking.Sockets.Lap2Socket.send_clove/3","type":"function"},{"doc":"Send out a TCP request and wait for a response.","ref":"LAP2.Networking.Sockets.Lap2Socket.html#send_tcp/3","title":"LAP2.Networking.Sockets.Lap2Socket.send_tcp/3","type":"function"},{"doc":"","ref":"LAP2.Networking.Sockets.UdpServer.html","title":"LAP2.Networking.Sockets.UdpServer","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Networking.Sockets.UdpServer.html#child_spec/1","title":"LAP2.Networking.Sockets.UdpServer.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1 .","ref":"LAP2.Networking.Sockets.UdpServer.html#init/1","title":"LAP2.Networking.Sockets.UdpServer.init/1","type":"function"},{"doc":"","ref":"LAP2.Networking.Sockets.UdpServer.html#send_dgram/3","title":"LAP2.Networking.Sockets.UdpServer.send_dgram/3","type":"function"},{"doc":"Start the UDP server.","ref":"LAP2.Networking.Sockets.UdpServer.html#start_link/1","title":"LAP2.Networking.Sockets.UdpServer.start_link/1","type":"function"},{"doc":"Terminate the UDP server.","ref":"LAP2.Networking.Sockets.UdpServer.html#terminate/2","title":"LAP2.Networking.Sockets.UdpServer.terminate/2","type":"function"},{"doc":"Parses a JSON file into a map.","ref":"LAP2.Utils.ConfigParser.html","title":"LAP2.Utils.ConfigParser","type":"module"},{"doc":"Parses a JSON file into a map.","ref":"LAP2.Utils.ConfigParser.html#get_config/1","title":"LAP2.Utils.ConfigParser.get_config/1","type":"function"},{"doc":"Common helper functions for working with ETS tables.","ref":"LAP2.Utils.EtsHelper.html","title":"LAP2.Utils.EtsHelper","type":"module"},{"doc":"Delete a value from an ETS table.","ref":"LAP2.Utils.EtsHelper.html#delete_value/2","title":"LAP2.Utils.EtsHelper.delete_value/2","type":"function"},{"doc":"Get a value from an ETS table.","ref":"LAP2.Utils.EtsHelper.html#get_value/2","title":"LAP2.Utils.EtsHelper.get_value/2","type":"function"},{"doc":"Insert a value into an ETS table.","ref":"LAP2.Utils.EtsHelper.html#insert_value/3","title":"LAP2.Utils.EtsHelper.insert_value/3","type":"function"},{"doc":"A collection of functions for working with JSON.","ref":"LAP2.Utils.JsonUtils.html","title":"LAP2.Utils.JsonUtils","type":"module"},{"doc":"Function for recursively converting a map's keys to atoms.","ref":"LAP2.Utils.JsonUtils.html#keys_to_atoms/1","title":"LAP2.Utils.JsonUtils.keys_to_atoms/1","type":"function"},{"doc":"Parses a JSON file into a map.","ref":"LAP2.Utils.JsonUtils.html#parse_json/1","title":"LAP2.Utils.JsonUtils.parse_json/1","type":"function"},{"doc":"Function for recursively converting the config names to atoms.","ref":"LAP2.Utils.JsonUtils.html#values_to_atoms/2","title":"LAP2.Utils.JsonUtils.values_to_atoms/2","type":"function"},{"doc":"Helper functions for generating clove information, checksums, splitting and reconstructing cloves, padding, etc. Handles serialising and deserialising cloves (simplifies serial data types).","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html","title":"LAP2.Utils.ProtoBuf.CloveHelper","type":"module"},{"doc":"Build the clove from the headers and data.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#create_clove/3","title":"LAP2.Utils.ProtoBuf.CloveHelper.create_clove/3","type":"function"},{"doc":"Deserialise a clove.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#deserialise/1","title":"LAP2.Utils.ProtoBuf.CloveHelper.deserialise/1","type":"function"},{"doc":"Send out the deserialised clove for routing.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#handle_deserialised_clove/3","title":"LAP2.Utils.ProtoBuf.CloveHelper.handle_deserialised_clove/3","type":"function"},{"doc":"Serialise a clove.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#serialise/1","title":"LAP2.Utils.ProtoBuf.CloveHelper.serialise/1","type":"function"},{"doc":"Verify the checksum of the clove.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#verify_checksum/1","title":"LAP2.Utils.ProtoBuf.CloveHelper.verify_checksum/1","type":"function"},{"doc":"Verify the clove's validity.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#verify_clove/1","title":"LAP2.Utils.ProtoBuf.CloveHelper.verify_clove/1","type":"function"},{"doc":"Verify the clove's headers.","ref":"LAP2.Utils.ProtoBuf.CloveHelper.html#verify_headers/1","title":"LAP2.Utils.ProtoBuf.CloveHelper.verify_headers/1","type":"function"},{"doc":"Helper functions for processing LAP2 requests. Verifies integrity, serves as interface for serialising/deserialising with ProtoBuf.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html","title":"LAP2.Utils.ProtoBuf.RequestHelper","type":"module"},{"doc":"Build the key exchange finalisation struct","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#build_fin_claimable/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.build_fin_claimable/1","type":"function"},{"doc":"Build the key exchange initialisation struct","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#build_init_claimable/6","title":"LAP2.Utils.ProtoBuf.RequestHelper.build_init_claimable/6","type":"function"},{"doc":"Build a key rotation request struct","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#build_key_rotation/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.build_key_rotation/1","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#build_request/4","title":"LAP2.Utils.ProtoBuf.RequestHelper.build_request/4","type":"function"},{"doc":"Build the key exchange response struct","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#build_resp_claimable/7","title":"LAP2.Utils.ProtoBuf.RequestHelper.build_resp_claimable/7","type":"function"},{"doc":"Build a regular symmetric key struct Note: HMAC key is set when the HMAC is computed","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#build_symmetric_crypto/0","title":"LAP2.Utils.ProtoBuf.RequestHelper.build_symmetric_crypto/0","type":"function"},{"doc":"Deserialise a request struct.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#deserialise/2","title":"LAP2.Utils.ProtoBuf.RequestHelper.deserialise/2","type":"function"},{"doc":"Deserialise to EncryptedRequest then finally to Request struct. If unencrypted, deserialise wrapped data. If encrypted, unwrap and decrypt request.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#deserialise_and_unwrap/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.deserialise_and_unwrap/1","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#deserialise_and_unwrap/3","title":"LAP2.Utils.ProtoBuf.RequestHelper.deserialise_and_unwrap/3","type":"function"},{"doc":"Encrypt a Request struct and serialise to EncryptedRequest struct.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#encrypt_and_wrap/3","title":"LAP2.Utils.ProtoBuf.RequestHelper.encrypt_and_wrap/3","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#format_export/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.format_export/1","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#format_import/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.format_import/1","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#format_sag_export/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.format_sag_export/1","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#format_sag_import/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.format_sag_import/1","type":"function"},{"doc":"Finish a key exchange with a remote proxy. Different from recv_finalise_exchange as this is called by the initiator.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#gen_finalise_exchange/3","title":"LAP2.Utils.ProtoBuf.RequestHelper.gen_finalise_exchange/3","type":"function"},{"doc":"Respond to a key exchange request from a remote proxy.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#gen_response/3","title":"LAP2.Utils.ProtoBuf.RequestHelper.gen_response/3","type":"function"},{"doc":"Initiate a key exchange with a remote proxy.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#init_exchange/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.init_exchange/1","type":"function"},{"doc":"Initiate key rotation with a remote proxy.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#init_key_rotation/2","title":"LAP2.Utils.ProtoBuf.RequestHelper.init_key_rotation/2","type":"function"},{"doc":"Finish a key exchange with a remote proxy. Different from gen_finalise_exchange as this is called by the receiver proxy.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#recv_finalise_exchange/3","title":"LAP2.Utils.ProtoBuf.RequestHelper.recv_finalise_exchange/3","type":"function"},{"doc":"Perform key rotation request with a remote proxy.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#rotate_keys/3","title":"LAP2.Utils.ProtoBuf.RequestHelper.rotate_keys/3","type":"function"},{"doc":"Serialise a request struct.","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#serialise/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.serialise/1","type":"function"},{"doc":"","ref":"LAP2.Utils.ProtoBuf.RequestHelper.html#wrap_unencrypted/1","title":"LAP2.Utils.ProtoBuf.RequestHelper.wrap_unencrypted/1","type":"function"},{"doc":"Helper functions for processing IDA Shares. Verifies integrity, serves as interface for serialising/deserialising with ProtoBuf.","ref":"LAP2.Utils.ProtoBuf.ShareHelper.html","title":"LAP2.Utils.ProtoBuf.ShareHelper","type":"module"},{"doc":"Deserialise a share.","ref":"LAP2.Utils.ProtoBuf.ShareHelper.html#deserialise/1","title":"LAP2.Utils.ProtoBuf.ShareHelper.deserialise/1","type":"function"},{"doc":"Format the aux data into a map.","ref":"LAP2.Utils.ProtoBuf.ShareHelper.html#format_aux_data/1","title":"LAP2.Utils.ProtoBuf.ShareHelper.format_aux_data/1","type":"function"},{"doc":"Reconstruct the data from the shares","ref":"LAP2.Utils.ProtoBuf.ShareHelper.html#reconstruct/1","title":"LAP2.Utils.ProtoBuf.ShareHelper.reconstruct/1","type":"function"},{"doc":"Serialise a share.","ref":"LAP2.Utils.ProtoBuf.ShareHelper.html#serialise/1","title":"LAP2.Utils.ProtoBuf.ShareHelper.serialise/1","type":"function"},{"doc":"Verify the share's validity.","ref":"LAP2.Utils.ProtoBuf.ShareHelper.html#verify_share/1","title":"LAP2.Utils.ProtoBuf.ShareHelper.verify_share/1","type":"function"},{"doc":"Module for performing mathematical matrix operations. The functions used for performing the vandermonde matrix operations are based on the follwoing repository: https://github.com/mmtan/IDA","ref":"LAP2.Math.Matrix.html","title":"LAP2.Math.Matrix","type":"module"},{"doc":"Calculate the sum of the products of all possible subsets of the list l, with a specified size m. Ensure that the result is within the finite field limit.","ref":"LAP2.Math.Matrix.html#elementary_symmetric_functions/3","title":"LAP2.Math.Matrix.elementary_symmetric_functions/3","type":"function"},{"doc":"Calculate the extended GCD of two numbers.","ref":"LAP2.Math.Matrix.html#extended_gcd/2","title":"LAP2.Math.Matrix.extended_gcd/2","type":"function"},{"doc":"Generate Vandermonde matrix of size n x m","ref":"LAP2.Math.Matrix.html#gen_vandermonde_matrix/3","title":"LAP2.Math.Matrix.gen_vandermonde_matrix/3","type":"function"},{"doc":"","ref":"LAP2.Math.Matrix.html#load_nif/0","title":"LAP2.Math.Matrix.load_nif/0","type":"function"},{"doc":"Calculate the dot product of two matrices, ensuring the result is within the finite field.","ref":"LAP2.Math.Matrix.html#matrix_dot_product/3","title":"LAP2.Math.Matrix.matrix_dot_product/3","type":"function"},{"doc":"Wrapper for the NIF matrix product calculation function.","ref":"LAP2.Math.Matrix.html#matrix_nif_product/3","title":"LAP2.Math.Matrix.matrix_nif_product/3","type":"function"},{"doc":"","ref":"LAP2.Math.Matrix.html#transpose/1","title":"LAP2.Math.Matrix.transpose/1","type":"function"},{"doc":"Perform modular inverse of a vandermonde matrix, ensuring that the matrix elements are within the finite field limit.","ref":"LAP2.Math.Matrix.html#vandermonde_inverse/2","title":"LAP2.Math.Matrix.vandermonde_inverse/2","type":"function"},{"doc":"","ref":"LAP2.Math.Matrix.html#vector_dot_product/3","title":"LAP2.Math.Matrix.vector_dot_product/3","type":"function"},{"doc":"The main module of the LAP2 server. This module is responsible for starting the supervision tree, loading the config and setting the log level.","ref":"LAP2.html","title":"LAP2","type":"module"},{"doc":"Kill main process supervisor (this stops the whole supervision tree)","ref":"LAP2.html#kill/1","title":"LAP2.kill/1","type":"function"},{"doc":"","ref":"LAP2.html#load_config/0","title":"LAP2.load_config/0","type":"function"},{"doc":"Start the server without a config file. The config files dev_config.json and prod_config.json can be found in the config dir. By default, the DEBUG config is used, if the environment variable LAP2_ENV is set to PROD , the prod config is used. To use a custom config file, set the environment variable LAP2_PROD_CONFIG_PATH or LAP2_DEV_CONFIG_PATH to the path of the config file.","ref":"LAP2.html#start/0","title":"LAP2.start/0","type":"function"},{"doc":"Start the server with a config map. This is useful for testing.","ref":"LAP2.html#start/1","title":"LAP2.start/1","type":"function"},{"doc":"Kill the child task","ref":"LAP2.html#terminate_child/2","title":"LAP2.terminate_child/2","type":"function"},{"doc":"Module for sending/receiving data via the network.","ref":"LAP2.Main.Master.html","title":"LAP2.Main.Master","type":"module"},{"doc":"Bootstrap the DHT table with a request to a known network node.","ref":"LAP2.Main.Master.html#bootstrap_dht/2","title":"LAP2.Main.Master.bootstrap_dht/2","type":"function"},{"doc":"Add a query to the cache so it can be retrieved for a response.","ref":"LAP2.Main.Master.html#cache_query/4","title":"LAP2.Main.Master.cache_query/4","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Main.Master.html#child_spec/1","title":"LAP2.Main.Master.child_spec/1","type":"function"},{"doc":"Deregister a listener with a given stream ID.","ref":"LAP2.Main.Master.html#deregister_listener/2","title":"LAP2.Main.Master.deregister_listener/2","type":"function"},{"doc":"Attempt to deregister a service with a given stream ID and its associated secret key.","ref":"LAP2.Main.Master.html#deregister_service/3","title":"LAP2.Main.Master.deregister_service/3","type":"function"},{"doc":"Delete a query from the cache. Used if a service does not wish to respond to a query.","ref":"LAP2.Main.Master.html#discard_query/4","title":"LAP2.Main.Master.discard_query/4","type":"function"},{"doc":"Initialise the proxy discovery process.","ref":"LAP2.Main.Master.html#discover_proxy/1","title":"LAP2.Main.Master.discover_proxy/1","type":"function"},{"doc":"","ref":"LAP2.Main.Master.html#get_listener_struct/2","title":"LAP2.Main.Master.get_listener_struct/2","type":"function"},{"doc":"","ref":"LAP2.Main.Master.html#get_registry_table/1","title":"LAP2.Main.Master.get_registry_table/1","type":"function"},{"doc":"Send a response to the appropriate listener socket.","ref":"LAP2.Main.Master.html#get_service_target/2","title":"LAP2.Main.Master.get_service_target/2","type":"function"},{"doc":"Initialise the data handler GenServer.","ref":"LAP2.Main.Master.html#init/1","title":"LAP2.Main.Master.init/1","type":"function"},{"doc":"","ref":"LAP2.Main.Master.html#pop_return/2","title":"LAP2.Main.Master.pop_return/2","type":"function"},{"doc":"Remember a query ID for a DHT request to verify the response","ref":"LAP2.Main.Master.html#register_dht_request/2","title":"LAP2.Main.Master.register_dht_request/2","type":"function"},{"doc":"Register a listener with a unique stream ID. :stdout for STDOUT {:tcp, {ip, port}} for TCP {:native, funct, service_id} for a native listener function","ref":"LAP2.Main.Master.html#register_listener/2","title":"LAP2.Main.Master.register_listener/2","type":"function"},{"doc":"","ref":"LAP2.Main.Master.html#register_return/3","title":"LAP2.Main.Master.register_return/3","type":"function"},{"doc":"Register a service with a given stream ID. This function returs a secret key needed to modify the registered service.","ref":"LAP2.Main.Master.html#register_service/3","title":"LAP2.Main.Master.register_service/3","type":"function"},{"doc":"","ref":"LAP2.Main.Master.html#request_remote/5","title":"LAP2.Main.Master.request_remote/5","type":"function"},{"doc":"Respond to a query with a given query ID.","ref":"LAP2.Main.Master.html#respond/5","title":"LAP2.Main.Master.respond/5","type":"function"},{"doc":"Lookup a service to get its associated stream ID.","ref":"LAP2.Main.Master.html#service_lookup/2","title":"LAP2.Main.Master.service_lookup/2","type":"function"},{"doc":"Get the registry table for a given master name.","ref":"LAP2.Main.Master.html#setup_introduction_point/2","title":"LAP2.Main.Master.setup_introduction_point/2","type":"function"},{"doc":"Start the Master process.","ref":"LAP2.Main.Master.html#start_link/1","title":"LAP2.Main.Master.start_link/1","type":"function"},{"doc":"Verify if a query ID is valid for a DHT request","ref":"LAP2.Main.Master.html#valid_dht_request?/2","title":"LAP2.Main.Master.valid_dht_request?/2","type":"function"},{"doc":"Module for handling ProxyManager requests.","ref":"LAP2.Main.ProxyManager.html","title":"LAP2.Main.ProxyManager","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Main.ProxyManager.html#child_spec/1","title":"LAP2.Main.ProxyManager.child_spec/1","type":"function"},{"doc":"","ref":"LAP2.Main.ProxyManager.html#debug/1","title":"LAP2.Main.ProxyManager.debug/1","type":"function"},{"doc":"","ref":"LAP2.Main.ProxyManager.html#handle_call/2","title":"LAP2.Main.ProxyManager.handle_call/2","type":"function"},{"doc":"Handle a discovery response.","ref":"LAP2.Main.ProxyManager.html#handle_discovery_response/3","title":"LAP2.Main.ProxyManager.handle_discovery_response/3","type":"function"},{"doc":"Handle a proxy request.","ref":"LAP2.Main.ProxyManager.html#handle_proxy_request/3","title":"LAP2.Main.ProxyManager.handle_proxy_request/3","type":"function"},{"doc":"Handle a regular proxy request/response.","ref":"LAP2.Main.ProxyManager.html#handle_regular_proxy/3","title":"LAP2.Main.ProxyManager.handle_regular_proxy/3","type":"function"},{"doc":"Initialise the data handler GenServer.","ref":"LAP2.Main.ProxyManager.html#init/1","title":"LAP2.Main.ProxyManager.init/1","type":"function"},{"doc":"Initialise the proxy discovery process.","ref":"LAP2.Main.ProxyManager.html#init_proxy/1","title":"LAP2.Main.ProxyManager.init_proxy/1","type":"function"},{"doc":"Remove a proxy from the pool.","ref":"LAP2.Main.ProxyManager.html#remove_proxy/2","title":"LAP2.Main.ProxyManager.remove_proxy/2","type":"function"},{"doc":"Send a query to a specific proxy.","ref":"LAP2.Main.ProxyManager.html#send_request/3","title":"LAP2.Main.ProxyManager.send_request/3","type":"function"},{"doc":"Send a response to a specific proxy.","ref":"LAP2.Main.ProxyManager.html#send_response/3","title":"LAP2.Main.ProxyManager.send_response/3","type":"function"},{"doc":"Start the ProxyManager process.","ref":"LAP2.Main.ProxyManager.html#start_link/1","title":"LAP2.Main.ProxyManager.start_link/1","type":"function"},{"doc":"Helper functions for processing the share handler state.","ref":"LAP2.Main.Helpers.ProcessorState.html","title":"LAP2.Main.Helpers.ProcessorState","type":"module"},{"doc":"Add a share and auxiliary information to the ETS table","ref":"LAP2.Main.Helpers.ProcessorState.html#add_share_to_ets/3","title":"LAP2.Main.Helpers.ProcessorState.add_share_to_ets/3","type":"function"},{"doc":"Add a message id to the drop list.","ref":"LAP2.Main.Helpers.ProcessorState.html#add_to_drop_list/2","title":"LAP2.Main.Helpers.ProcessorState.add_to_drop_list/2","type":"function"},{"doc":"Cache a share in the share_info map.","ref":"LAP2.Main.Helpers.ProcessorState.html#cache_share/2","title":"LAP2.Main.Helpers.ProcessorState.cache_share/2","type":"function"},{"doc":"Delete a share from the share_info map.","ref":"LAP2.Main.Helpers.ProcessorState.html#delete_from_cache/2","title":"LAP2.Main.Helpers.ProcessorState.delete_from_cache/2","type":"function"},{"doc":"Route a share to the appropriate processing stage.","ref":"LAP2.Main.Helpers.ProcessorState.html#route_share/2","title":"LAP2.Main.Helpers.ProcessorState.route_share/2","type":"function"},{"doc":"Contains helper functions for processing common proxy requests and responses","ref":"LAP2.Main.Helpers.ProxyHelper.html","title":"LAP2.Main.Helpers.ProxyHelper","type":"module"},{"doc":"Accept a proxy request. Respond with an acknowledgement. Add the relays to the proxy pool and return updated Proxy GenServer state.","ref":"LAP2.Main.Helpers.ProxyHelper.html#accept_proxy_request/3","title":"LAP2.Main.Helpers.ProxyHelper.accept_proxy_request/3","type":"function"},{"doc":"Validate the length of the anonymous path.","ref":"LAP2.Main.Helpers.ProxyHelper.html#handle_discovery_response/3","title":"LAP2.Main.Helpers.ProxyHelper.handle_discovery_response/3","type":"function"},{"doc":"Finalise the key exchange.","ref":"LAP2.Main.Helpers.ProxyHelper.html#handle_fin_key_exhange/3","title":"LAP2.Main.Helpers.ProxyHelper.handle_fin_key_exhange/3","type":"function"},{"doc":"","ref":"LAP2.Main.Helpers.ProxyHelper.html#handle_key_exchange_ack/2","title":"LAP2.Main.Helpers.ProxyHelper.handle_key_exchange_ack/2","type":"function"},{"doc":"Handle a key rotation request.","ref":"LAP2.Main.Helpers.ProxyHelper.html#handle_key_rotation/3","title":"LAP2.Main.Helpers.ProxyHelper.handle_key_rotation/3","type":"function"},{"doc":"Handle a key rotation acknowledgement.","ref":"LAP2.Main.Helpers.ProxyHelper.html#handle_key_rotation_ack/2","title":"LAP2.Main.Helpers.ProxyHelper.handle_key_rotation_ack/2","type":"function"},{"doc":"Route proxy query to the correct application listener via the Master module.","ref":"LAP2.Main.Helpers.ProxyHelper.html#handle_proxy_query/3","title":"LAP2.Main.Helpers.ProxyHelper.handle_proxy_query/3","type":"function"},{"doc":"Initialise proxy request. (outbound) Generate a new EncryptedRequest struct and send it to random neighbors. @param registry_table - RegistryTable struct @param clove_seq - Clove sequence number @param cloves - Number of cloves to be sent","ref":"LAP2.Main.Helpers.ProxyHelper.html#init_proxy_request/3","title":"LAP2.Main.Helpers.ProxyHelper.init_proxy_request/3","type":"function"},{"doc":"Remove a proxy from the proxy pool.","ref":"LAP2.Main.Helpers.ProxyHelper.html#remove_proxy/2","title":"LAP2.Main.Helpers.ProxyHelper.remove_proxy/2","type":"function"},{"doc":"Send an outbound proxy query to a single specific proxy.","ref":"LAP2.Main.Helpers.ProxyHelper.html#send_to_proxy/4","title":"LAP2.Main.Helpers.ProxyHelper.send_to_proxy/4","type":"function"},{"doc":"Module for handling reconstructed requests from the Share Handler. Route to Proxy or Master module.","ref":"LAP2.Main.StructHandlers.RequestHandler.html","title":"LAP2.Main.StructHandlers.RequestHandler","type":"module"},{"doc":"Handle a request from the Share Handler.","ref":"LAP2.Main.StructHandlers.RequestHandler.html#handle_request/3","title":"LAP2.Main.StructHandlers.RequestHandler.handle_request/3","type":"function"},{"doc":"Handle share caching and reassembly.","ref":"LAP2.Main.StructHandlers.ShareHandler.html","title":"LAP2.Main.StructHandlers.ShareHandler","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"LAP2.Main.StructHandlers.ShareHandler.html#child_spec/1","title":"LAP2.Main.StructHandlers.ShareHandler.child_spec/1","type":"function"},{"doc":"Reassemble network received shares and route along pipeline.","ref":"LAP2.Main.StructHandlers.ShareHandler.html#deliver/3","title":"LAP2.Main.StructHandlers.ShareHandler.deliver/3","type":"function"},{"doc":"Initialise the share handler GenServer.","ref":"LAP2.Main.StructHandlers.ShareHandler.html#init/1","title":"LAP2.Main.StructHandlers.ShareHandler.init/1","type":"function"},{"doc":"Reconstruct service request from shares.","ref":"LAP2.Main.StructHandlers.ShareHandler.html#service_deliver/3","title":"LAP2.Main.StructHandlers.ShareHandler.service_deliver/3","type":"function"},{"doc":"Start the ShareHandler process.","ref":"LAP2.Main.StructHandlers.ShareHandler.html#start_link/1","title":"LAP2.Main.StructHandlers.ShareHandler.start_link/1","type":"function"},{"doc":"Cleanup the ETS table on exit.","ref":"LAP2.Main.StructHandlers.ShareHandler.html#terminate/2","title":"LAP2.Main.StructHandlers.ShareHandler.terminate/2","type":"function"},{"doc":"","ref":"readme.html","title":"LAP2","type":"extras"},{"doc":"","ref":"readme.html#lightweight-anonymous-p2p-overlay-network","title":"LAP2 - Lightweight Anonymous P2P Overlay Network","type":"extras"},{"doc":"&amp;nbsp;&amp;nbsp;The significance of privacy and anonymity in preserving human rights is paramount, especially in the current digital era, where internet users are exposed to various data collection risks such as corporate surveillance, ransomware, and government mass surveillance. The goal of the LAP2 project is to create an anonymous peer-to-peer overlay network that reduces cryptographic overhead for intermediate relays in proxy chains, making it more accessible for usage by low-spec IoT devices. &lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;LAP2 is inspired by and builds upon existing solutions for anonymous peer-to-peer networks such as Tor and I2P while attempting to improve performance using recently published research on a new, more efficient routing technique called Garlic Cast. Furthermore, LAP2 extends the functionality of the existing deniable authenticated key exchange algorithm RSDAKE to introduce the first claimable deniable authenticated key exchange protocol, C-RSDAKE, complete with an open-source Rust implementation.","ref":"readme.html#introduction","title":"LAP2 - Introduction","type":"extras"},{"doc":"&amp;nbsp;&amp;nbsp;The LAP2 project is implemented using the Elixir programming language. The main objective is to create an anonymous peer-to-peer overlay network with a significantly lower cryptographic overhead compared to conventional anonymity networks such as TOR and I2P. This will allow low-spec IoT devices to be incorporated into the network.&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;To improve performance in certain sections, NIFs (Native Implemented Functions) are used to implement computationally intensive algorithms in C and several cryptographic schemes in Rust.","ref":"readme.html#about","title":"LAP2 - About","type":"extras"},{"doc":"&amp;nbsp;&amp;nbsp;Garlic Cast is a new, more efficient routing technique that LAP2 uses to improve network performance. It does not require the usage of layered cryptography between intermediate relays, thus increasing performance.","ref":"readme.html#garlic-cast","title":"LAP2 - Garlic Cast","type":"extras"},{"doc":"&amp;nbsp;&amp;nbsp;LAP2 extends the functionality of the existing deniable authenticated key exchange algorithm RSDAKE to introduce the first claimable deniable authenticated key exchange protocol, C-RSDAKE, complete with an open-source Rust implementation. When introduced within the AP2P network, the C-RSDAKE construction empowers users to verify each other's identities through cryptographic means independent of the network. This can be a desirable property for an anonymous network due to the lack of central certificate authorities and will extend the network's ability to provide a secure platform for expressing oneself online while mitigating the risk of third-party monitoring and interference.","ref":"readme.html#c-rsdake","title":"LAP2 - C-RSDAKE","type":"extras"},{"doc":"The documentation for the LAP2 project can be found here .&lt;br&gt; It is recommended that you use the project inside a Docker container. To do that, follow the instructions in the next section: Docker Setup Install Docker by following the instructions here Build a Docker container for the project by running the following command in the root directory: docker build -t lap2 . Start the container in the LAP2 debug shell (IEx) with the following command: docker run -it lap2 Instructions on how to use the debug shell can be found in the section below. Note: If you want to run a different shell inside the container, set the ENTRYPOINT in the Dockerfile to the desired shell (e.g., /bin/bash ), then rebuild the container and run it with the same command as above. That's it! Now you can use the project inside a Docker container. Note: If ran interactively using docker, the project should automatically start in the IEx shell (unless the Dockerfile entrypoint is changed). IEx interactive shell The LAP2 project can be demoed using Elixir's interactive shell (IEx). To improve the user experience, a utility script sets up the IEx environment (aliases, utility lambdas, etc). To start the shell, run the following command in the root directory: mix run The shell can be exited by pressing Ctrl+C twice. The IEx shell can be used to test out much of the functionality of the modules in the project (with the exception of private functions). The following sections show some examples of how to test out some of LAP2's most important features. If needed, a short syntax reference for Elixir can be found here , however the code examples should provide enough context to understand what is going on. File transfer example We can test out the file transfer functionality of the project by using the NetUtils module to simulate the network of nodes and then using the FileUtils module to transfer files between them. Here is a general example of testing out the network by performing a file transfer using the IEx shell: iex(1)&gt; addresses = NetUtils . start_network ( 50 , 40000 ) # Start network with 50 nodes [ &quot;aa7707a292f29733&quot; , &quot;5280647b9387f11f&quot; , ... ] iex(2)&gt; NetUtils . bootstrap_network ( ) # Setup DHT tables :ok iex(3)&gt; [ host , client ] = Enum . take_random ( addresses , 2 ) # Pick random host and client [ &quot;4db73be2deb45f76&quot; , &quot;5585735a2ed3018a&quot; ] iex(4)&gt; Enum . each ( 0 .. 3 , fn _ -&gt; # Setup 4 anonymous proxies for both nodes ...(4)&gt; NetUtils . find_anon_proxy ( host ) ...(4)&gt; NetUtils . find_anon_proxy ( client ) ...(4)&gt; end ) :ok iex(5)&gt; { :ok , fileio_host } = NetUtils . run_fileio ( host ) # Start FileIO host service { :ok , &quot;ed7494faa04094d4&quot; } iex(6)&gt; { :ok , fileio_cli } = NetUtils . run_fileio ( client ) # Start FileIO client service { :ok , &quot;7df091674c3d4f7f&quot; } iex(7)&gt; NetUtils . find_intro_point ( host , [ fileio_host ] ) # Find an introduction point :ok iex(8)&gt; intros = NetUtils . get_introduction_points ( fileio_host ) # Get the intro point list (if empty, rerun previous command) [ &quot;03ce49e5dfc1091f&quot; ] iex(9)&gt; FileIO . request_file ( intros , fileio_host , &quot;README.md&quot; , &quot;/tmp/readme.md&quot; , fileio_cli ) # Request remote file :ok iex(10)&gt; ls &quot;/tmp/readme.md&quot; # Check if file was written (debug output should indicate success or fail) / tmp / readme . md iex(11)&gt; FileIO . stop_service ( fileio_host ) :ok iex(12)&gt; FileIO . stop_service ( fileio_cli ) :ok iex(13)&gt; NetUtils . stop_network ( ) true C-RSDAKE example In the previous example C-RSDAKE was used during the anonymous route establishment phase. To test out the C-RSDAKE protocol in isolation, refer to the code example in section C-RSDAKE . Networking NetUtils To start off, use the NetUtils.spawn_network function to simulate a network environment by starting multiple network nodes simultaneously. The function takes as arguments the number of nodes to be started and the starting port of the first node. The port numbers for subsequent nodes are incremented by 1 from this number. It returns a list of network addresses (string type) for the spawned nodes. In the following example, we are spawning 100 nodes starting from port 40000. The returned network addresses are stored in the addresses variable: iex(1)&gt; addresses = NetUtils . spawn_network ( 100 , 40000 ) [ ... ] Note: The number of running nodes is limited by the number of available ports on the host machine. If you get an error saying that the port is already in use, try using a different port number. Try to run less than 1000 nodes to avoid hitting an open port or experiencing performance issues. The network address of any node can be obtained using the Enum module as such: iex(2)&gt; address_0 = Enum . at ( addresses , 0 ) # Take the address at index 0 &quot;...&quot; iex(3)&gt; rand_address = Enum . random ( addresses ) # Take a random address &quot;...&quot; Alternatively, nodes can be spawned individually using NetUtils.start_node . To do this, first construct a config file for the node using the NetUtils.make_config function, then pass the config file to the NetUtils.start_node function. However, if NetUtils.start_network has not been called before, the ETS table must be created manually before spawning the node. This can be done using the following commands: iex(1)&gt; :ets . new ( :network_registry , [ :named_table , :set , :public ] ) # Create ETS table iex(2)&gt; udp_port = 40000 # Set UDP port 40000 iex(3)&gt; tcp_port = 40000 # Set TCP port 40000 iex(4)&gt; addr = Generator . generate_hex ( 8 ) # Set network address, any string will do &quot;...&quot; iex(5)&gt; config = NetUtils . make_config ( addr , udp_port , tcp_port ) # Create config %{ ... } iex(6)&gt; NetUtils . spawn_node ( config ) # Start node :ok Once the network has been started, the nodes' routing tables should be bootstrapped. This can be accomplished in multiple ways: If you wish to bootstrap all network nodes without making any network requests (quickest and most reliable way), use NetUtils.seed_network . This function will update each node's routing table with a copy of the global one (stored in an ETS table). This function takes no arguments: iex ( ) &gt; NetUtils . seed_network ( ) :ok Alternatively, if you wish to bootstrap all network nodes by using network DHT update requests, use NetUtils.bootstrap_network . This function will first seed a single node with the global registry table, then instruct all other nodes to request a DHT update from it. Again, this function takes no arguments and returns an atom of the status of the operation: iex ( ) &gt; NetUtils . bootstrap_network ( ) :ok The final option is to bootstrap individual nodes. To do that, first use NetUtils.seed_node to setup a random node's DHT table as before. This function accepts no arguments but returns the IP address and port of the node that was seeded: iex ( ) &gt; { :ok , seed_addr } = NetUtils . seed_node ( ) { :ok , &quot;...&quot; } Then, use NetUtils.bootstrap_node to instruct another node to request a DHT update from the seeded node. This function takes the network address of the client node and the IP address and port of DHT provider node: iex ( ) &gt; NetUtils . update_dht ( lap2_addr , seed_addr ) :ok This process can be repeated to bootstrap the entire network (which is exactly what NetUtils.bootstrap_network does). To check the contents of a node's routing table, use NetUtils.inspect_dht . This function takes the network address of the node as an argument and returns a map of the node's routing table: iex ( ) &gt; NetUtils . inspect_dht ( lap2_addr ) %{ &quot;...&quot; =&gt; { &quot;127.0.0.1&quot; , ... } , ... } Once the nodes have had their routing tables set up, they can start communicating with each other. To set up anonymous routes, select any node and use NetUtils.find_anon_proxy to instruct it to find an anonymous proxy. This function takes the network address of the node as an argument and returns the status of the operation: iex ( ) &gt; NetUtils . find_anon_proxy ( lap2_addr ) :ok The function can be called multiple times to establish multiple proxies: iex ( ) &gt; Enum . each ( 1 .. num_proxies , fn _ -&gt; NetUtils . find_anon_proxy ( lap2_addr ) end ) :ok Once a sufficient number of proxies has been established (depends on config setup, usually &gt;1 in DEV environment), a node can request a random proxy to become its introduction point. To do this, use NetUtils.find_intro_point . Arguments: This function expects the following arguments: lap2_addr : (string) The network address of the node requesting the introduction point. service_identifier : (string) The service identifier of the service that the node wishes to access. See how to generate service identifiers in the FileUtils section. iex ( ) &gt; NetUtils . find_intro_point ( lap2_addr , service_identifier ) :ok Verify that an introduction point has been setup and find its network address by using NetUtils.list_intro_points (no arguments required): iex ( ) &gt; NetUtils . list_intro_points ( ) %{ ... } Retrieving remote files anonymously is covered in the FileUtils section. Finally, to stop the network, use NetUtils.stop_network . This function takes no arguments and returns the status of the operation: iex ( ) &gt; NetUtils . stop_network ( ) :ok If needed, individual nodes can be stopped using NetUtils.stop_node . This function takes the network address of the node as an argument and returns the status of the operation: iex ( ) &gt; NetUtils . stop_node ( lap2_addr ) :ok This just about covers the networking section of the LAP2 project. The following sections will cover the other modules in the project. Cryptography The cryptographic section has a wide range of modules that can be tested out. Unlike the networking section, the CryptoUtils module only provides a few functions for encoding/decoding data to hex and base64. Since these modules are not designed to be used from the command line, their usage is a little less straightforward (deeply nested structures). I recommend looking at the unit tests and docs for examples that haven't been covered in this README.&lt;br&gt;&lt;br&gt; The following modules are available in the crypto section: CryptoNifs - Cryptographic primitives implemented in Rust NIFs. Avoid calling these functions directly where possible, they can throw exceptions if argument sizes are not correct (the code is memory safe but debugging Rust NIF exceptions can be a pain).&lt;br&gt; CryptoUtils - Provides functions for encoding/decoding data to hex and base64.&lt;br&gt; ClaimableRS - Implements the claimable ring signature scheme.&lt;br&gt; RSDAKE - Implements the RSDAKE protocol (out-of-date, use C_RSDAKE instead).&lt;br&gt; C_RSDAKE - Implements the Claimable RSDAKE key exchange protocol.&lt;br&gt; RabinIDA - Implements Rabin's IDA.&lt;br&gt; SecureIDA - Implements a security enhanced IDA using Rabin's IDA for data dispersal and Shamir's secret sharing for symmetric key dispersal.&lt;br&gt; CryptoUtils The CryptoUtils module provides functions for encoding/decoding data to hex and base64, as well as a few convenience functions for various crypto schemes. These functions can be used to encode and more easily transfer data to and from external tools. The following functions are available: CryptoUtils.list_to_hex/1 - Converts a charlist to a hex string. CryptoUtils.hex_to_list/1 - Converts a hex string to a charlist. CryptoUtils.list_to_b64/1 - Converts a charlist to a base64 string. CryptoUtils.b64_to_list/1 - Converts a base64 string to a charlist. CryptoUtils.gen_ring/3 - Given a public key, ring index and ring size, generate a ring of public keys with the given public key at the given index (demo in next section). iex(1)&gt; list = [ 99 , 104 , 97 , 114 , 108 , 105 , 115 , 116 ] &#39;charlist&#39; iex(2)&gt; CryptoUtils . list_to_hex ( list ) &quot;636861726C697374&quot; iex(3)&gt; |&gt; CryptoUtils . hex_to_list ( ) # The pipe operator ( |&gt; ) is used to pass the result of the previous function call as the first argument to the next function call &#39;charlist&#39; iex(4)&gt; |&gt; CryptoUtils . list_to_b64 ( ) &quot;Y2hhcmxpc3Q=&quot; iex(5)&gt; |&gt; CryptoUtils . b64_to_list ( ) &#39;charlist&#39; iex(6)&gt; == list true CryptoNifs The CryptoNifs module provides the cryptographic primitives on which the rest of the crypto modules are built (except RabinIDA and SecureIDA). These primitives are implemented in Rust NIFs for performance reasons. The following functions are available: CryptoNifs.prf_gen/1 - Generates a pseudorandom function (PRF) key. Takes the size of the key in bits as an argument and returns the key as a binary. CryptoNifs.prf_eval/2 - Evaluates a PRF. Takes the secret key and input as arguments and returns a 128-bit output as a charlist. iex(1)&gt; prf_sk = CryptoNifs . prf_gen ( 256 ) [ 230 , 75 , 38 , 236 , 139 , 109 , 101 , 23 , 114 , 235 , 115 , 57 , 0 , 0 , 248 , 80 , 143 , 19 , 176 , 131 , 149 , 133 , 134 , 221 , 126 , 129 , 109 , 217 , 59 , 237 , 209 , 220 ] iex(2)&gt; CryptoNifs . prf_eval ( prf_sk , &#39;RANDOM SEED DATA&#39; ) [ 14 , 74 , 45 , 113 , 94 , 226 , 43 , 87 , 30 , 99 , 15 , 167 , 131 , 202 , 127 , 41 ] CryptoNifs.commit_gen/2 - Generates a commitment. Takes the secret key and message as arguments and returns the commitment as a binary. CryptoNifs.commit_vrfy/3 - Verifies the validity of a commitment. Takes the secret key, message and commitment as arguments and returns a boolean. iex(3)&gt; commitment = CryptoNifs . commit_gen ( prf_sk , &#39;Commitment message&#39; ) [ 63 , 15 , 188 , 48 , 50 , 209 , 247 , 12 , 240 , 207 , 11 , 6 , 128 , 240 , 3 , 134 , 128 , 127 , 108 , 226 , 82 , 192 , 45 , 29 , 241 , 124 , 207 , 101 , 241 , 49 , 114 , 197 ] iex(4)&gt; CryptoNifs . commit_vrfy ( prf_sk , &#39;Commitment message&#39; , commitment ) true iex(5)&gt; CryptoNifs . commit_vrfy ( prf_sk , &#39;Invalid message&#39; , commitment ) false CryptoNifs.rs_nif_gen/0 - Generates a secret and public key pair for the SAG (Spontaneous Anonymous Group) ring signature scheme. The result is returned as a tuple of charlists (use the wrapper ClaimableRS.rs_gen/0 instead). CryptoNifs.rs_nif_sign/4 - Signs a message using the SAG ring signature scheme. Takes index of the signer in the ring, the signer's secret key, the ring of public keys (list of charlists) and the message to be signed (charlist). The function returns a ring signature tuple containing the signature challenge, response, and ring (charlist, list(charlist), list(charlist)). Use the wrapper ClaimableRS.rs_sign/4 instead for argument size verification. CryptoNifs.rs_nif_vrfy/4 - Verifies the validity of an SAG ring signature. Expects as input the signature challenge (charlist), the ring of public keys (list of charlists), the challenge responses (list of charlists) and the message that was signed. Returns a true if the signature is valid, false otherwise. Use the wrapper ClaimableRS.rs_vrfy/2 instead for argument size verification and overall better interface. CryptoUtils.gen_ring/3 - Creates a ring of public keys. Expects the ring position of the signer (integer index, starting from 0), the public key of the signer and the size of the ring. This is a utility function for quickly creating rings for the signature scheme. Returns a ring in the form of a list of public keys (charlists). iex(1)&gt; { sk , pk } = CryptoNifs . rs_nif_gen ( ) # Generate key pair { [ ... ] , [ ... ] } iex(2)&gt; ring_idx = 0 # The index position of the signer in the ring iex(3)&gt; ring_size = 3 # The number of ring participants (including the signer) iex(4)&gt; ring = CryptoUtils . gen_ring ( ring_idx , pk , ring_size ) # Generate a ring [ [ ... ] , [ ... ] , [ ... ] ] iex(5)&gt; { chal , new_ring , resp } = CryptoNifs . rs_nif_sign ( 0 , sk , ring , &#39;Test message for signing&#39; ) # Sign message { [ ... ] , [ ... ] , [ ... ] } iex(6)&gt; CryptoNifs . rs_nif_vrfy ( chal , new_ring , resp , &#39;Test message for signing&#39; ) # Check valid signature true iex(7)&gt; CryptoNifs . rs_nif_vrfy ( chal , new_ring , resp , &#39;Invalid message&#39; ) # Check invalid signature false Note: The contents of the charlists have been replaced with ... for readability. The charlists in this crypto modules are essentially integer lists of type uint8 (0-255). CryptoNifs.standard_signature_gen/0 - Standard signature scheme key generation function. Returns a tuple of secret and verification keys (charlists). CryptoNifs.standard_signature_sign/3 - Probabilistic signature scheme signing function (RSA-PSS). Expects as arguments the signer's secret key, message for signing and randomness as a seed. Returns the RSA-PSS signature as a charlist. CryptoNifs.standard_signature_vrfy/3 - Probabilistic signature scheme verification function (RSA-PSS). Expects as arguments the signature, signer's verification key and message for verification and signature. Returns a boolean. iex(1)&gt; rand = CryptoNifs . prf_gen ( 256 ) # Generate randomness [ ... ] iex(2)&gt; { sk , vk } = CryptoNifs . standard_signature_gen ( ) # Generate RSA keys { [ ... ] , [ ... ] } iex(3)&gt; signature = CryptoNifs . standard_signature_sign ( sk , &#39;Test message for signing&#39; , rand ) # Sign message [ ... ] iex(4)&gt; CryptoNifs . standard_signature_vrfy ( signature , vk , &#39;Test message for signing&#39; ) # Verify signature true iex(5)&gt; CryptoNifs . standard_signature_vrfy ( signature , vk , &#39;Invalid message&#39; ) # Invalid signature false ClaimableRS The ClaimableRS module is a contains a few wrappers for the CryptoNifs module, as well as functions for generating, signing and verifying claimable ring signatures. The module is used in the C_RSDAKE module for using claimable ring signatures in the RSDAKE protocol. The following section does not include the wrappers for the CryptoNifs functions, as they are essentially the same as the ones in the CryptoNifs module. The other functions are as follows: ClaimableRS.crs_gen/0 - Generates a secret and verification key pair for the claimable ring signature scheme, returned as map with sk: and vk: keys. ClaimableRS.crs_sign/4 - Signs a message using the claimable ring signature scheme. Similarly to ClaimableRS.rs_sign/4 , it takes as arguments the ring index of the signer, the signer's secret claimable ring signature key, the ring of public keys and the message to be signed. Returns a tuple of {:ok, SAG} or {:error, atom}, where SAG is a struct containing the signature challenge, response and ring and atom is the error that has occured. ClaimableRS.crs_vrfy/2 - Verifies the validity of a claimable ring signature. Expects as arguments the SAG struct generated on signing and the message that has been signed. Returns an {:ok, boolean} if the arguments are valid, or {:error, atom} with information about the error in the atom. ClaimableRS.crs_claim/3 - Produces a claim for a given ring signature. Expects as arguments the ring index of the signer, the signer's secret claimable ring signature key and the claimable signature (SAG struct) for which the claim will be made. If valid, returns {:ok, claim} where the claim is a tuple of the commitment randomness and standard signature. If invalid, returns {:error, atom} with information about the error in the atom. ClaimableRS.crs_vrfy_claim/3 - Verifies the validity of a claim for a given ring signature. Expects as arguments the claim, the ring index of the signer and the claimable signature (SAG struct) for which the claim will be made. If valid, returns {:ok, boolean}. If invalid, returns {:error, atom} with information about the error in the atom. ClaimableRS.sag_to_charlist/1 - Deconstructs a SAG struct to a charlist. Expects as argument the SAG struct. Returns a list of the challenge, ring and responses (like in CryptoNifs.rs_nif_sign/4 ). iex(1)&gt; ring_idx = 0 iex(2)&gt; %{ sk : sk , vk : vk } = ClaimableRS . crs_gen ( ) # Generate claimable RS key pair %{ sk : { { [ ... ] , [ ... ] } , [ ... ] , [ ... ] , [ ... ] } , vk : { [ ... ] , [ ... ] } } iex(3)&gt; { pk_rs , _ } = vk # Get the RS pub key from the CRS pub key { [ ... ] , [ ... ] } iex(4)&gt; ring = CryptoUtils . gen_ring ( ring_idx , pk_rs , 3 ) # Generate a ring of size 3 [ [ ... ] , [ ... ] , [ ... ] ] iex(5)&gt; { :ok , ring_sig } = ClaimableRS . crs_sign ( 0 , sk , ring , &#39;Message to be signed&#39; ) # Sign message { :ok , % SAG { chal : [ ... ] , ring : [ [ ... ] , [ ... ] , [ ... ] ] , resp : [ [ ... ] , [ ... ] , [ ... ] ] , commitment : [ ... ] , __uf__ : [ ] } } iex(6)&gt; ClaimableRS . crs_vrfy ( ring_sig , &#39;Message to be signed&#39; ) # Verify signature { :ok , true } iex(7)&gt; ClaimableRS . crs_vrfy ( ring_sig , &#39;Different (invalid) message&#39; ) { :ok , false } iex(8)&gt; { :ok , claim } = ClaimableRS . crs_claim ( 0 , sk , ring_sig ) # Generate claim { :ok , { [ ... ] , [ ... ] } } iex(9)&gt; ClaimableRS . crs_vrfy_claim ( vk , ring_sig , claim ) # Verify claim { :ok , true } C_RSDAKE The C_RSDAKE module contains functions for performing the RSDAKE key exchange protocol using claimable ring signature schemes. It provides 4 functions, representing each of the stages in the key exchange protocol. The functions are as follows: C_RSDAKE.initialise/1 - Generate the first message in the protocol. Expects as a single argument the identity of the sender as a charlist. If valid, it returns {:ok, {crypto_state, msg}} where crypto_state is a struct containing all crypto structs needed for future stages of the exchange and msg is the message to be sent to the receiver. If invalid (argument type error), it returns {:error, :invalid_identity}. C_RSDAKE.respond/3 - Generate a response to the first message of the exchange. Expects as arguments the identity of the receiver, long-term claimable ring signature key pair and the initial exchange message. If successful, it returns {:ok, {crypto_state, msg}} where crypto_state is a struct containing all crypto structs needed for future stages of the exchange and msg is the response to be sent to the receiver. If invalid (argument error), it returns {:error, atom}, where atom includes information for the error type. C_RSDAKE.finalise/3 - Generate the final message of the exchange. Expects as arguments the identity of the sender, crypto_struct generated by the C_RSDAKE.initialise/1 function and the response from the second stage of the exchange. If successful, it returns {:ok, {crypto_state, msg}} where crypto_state is a struct containing all crypto structs needed for future stages of the exchange and msg is the final message to be sent to the receiver. If invalid (argument error), it returns {:error, atom}, where atom includes information for the error type. C_RSDAKE.verify_final/3 - Verify the final message of the exchange. Expects as arguments the identity of the receiver, crypto_struct generated by the C_RSDAKE.initialise/1 function and the final message from the third stage of the exchange. If successful, it returns {:ok, boolean} where the boolean indicates the validity of the final message. If invalid (argument error), it returns {:error, atom}, where atom includes information for the error type. iex(1)&gt; init_id = &#39;INITIATOR_IDENTITY&#39; # The identity of the initiator &#39;INITIATOR_IDENTITY&#39; iex(2)&gt; recv_id = &#39;RECEPIENT_IDENTITY&#39; # The identity of the recepient &#39;RECEPIENT_IDENTITY&#39; iex(3)&gt; { :ok , { init_struct , { _ , init_msg } } } = C_RSDAKE . initialise ( init_id ) # Long structure omitted iex(4)&gt; lt_keys = ClaimableRS . crs_gen ( ) # Generate long-term CRS keys for responder %{ sk : { { [ ... ] } , [ ... ] , [ ... ] , [ ... ] } , vk : { [ ... ] , [ ... ] } } iex(5)&gt; { :ok , { resp_struct , { _ , resp_msg } } } = C_RSDAKE . respond ( recv_id , lt_keys , init_msg ) # Long structure omitted iex(6)&gt; { :ok , { fin_struct , { _ , fin_msg } } } = C_RSDAKE . finalise ( init_id , init_struct , resp_msg ) # Long structure omitted iex(7)&gt; C_RSDAKE . verify_final ( recv_id , resp_struct , fin_msg ) { :ok , true } iex(8)&gt; resp_struct . shared_secret == fin_struct . shared_secret # Check that the shared secret is the same for both parties true iex(9)&gt; resp_struct . shared_secret # The shared secret (responder) &lt;&lt; ... &gt;&gt; This concludes the cryptographic module tests. Below are example tests for the information dispersal modules (Rabin's IDA and Security Enhanced IDA). RabinIDA This is an implementation of Rabin's Information Dispersal Algorithm. It provides 4 functions, two of which are used for splitting and reconstructing data and the other two are only used for encoding/decoding the data output for serialisation and will not be described here. To improve performance, this module calls a C NIF to perform matrix multiplication operations. The available functions are: RabinIDA.split/3 - Split a binary into n shares. Expects as arguments the binary to be split, the number of shares to be generated (n) and the size of each share, which is also the reconstruction threshold. Returns a list of maps with the data and index of each share (accessible via the :data, :idx keys respectively). RabinIDA.reconstruct/1 - Attempt to reconstruct the original data from the a list of maps generated by the RabinIDA.split/3 function. If successful, it returns {:ok, binary} where binary is the original data. If unsuccessful, it returns {:error, nil}. iex(1)&gt; shares = RabinIDA . split ( &quot;This will be split into 4 shares&quot; , 4 , 4 ) [ %{ data : &lt;&lt; ... &gt;&gt; , share_idx : 1 } , %{ data : &lt;&lt; ... &gt;&gt; , share_idx : 2 } , %{ data : &lt;&lt; ... &gt;&gt; , share_idx : 3 } , %{ data : &lt;&lt; ... &gt;&gt; , share_idx : 4 } ] iex(2)&gt; RabinIDA . reconstruct ( shares ) { :ok , &quot;This will be split into 4 shares&quot; } iex(3)&gt; new_shares = RabinIDA . split ( &quot;This will be split into 4 shares with threshold 2&quot; , 4 , 2 ) iex(3)&gt; rand_shares = Enum . take_random ( new_shares , 2 ) # Take 2 random shares out of the 4 [ %{ data : &lt;&lt; ... &gt;&gt; , share_idx : 2 } , %{ data : &lt;&lt; ... &gt;&gt; , share_idx : 1 } ] iex(4)&gt; RabinIDA . reconstruct ( rand_shares ) { :ok , &quot;This will be split into 4 shares with threshold 2&quot; } Note: The reconstruction will only work if the number of shares passed to it is equal to the reconstruction threshold. The example above shows how a random number of items from a list can be taken using Enum.take_random/2 . SecureIDA This module is an implementation of a security enhanced information dispersal algorithm. Overall its usage is almost identical to RabinIDA, with the exception that it returns more complicated structs and handles errors better. It works by encrypting the data with AES256-CBC using a random key and IV, splitting the data into shares using RabinIDA and splitting the key intro shares using Shamir's Secret Sharing Scheme, then adding a part of each to a message. The available functions are: SecureIDA.disperse/4 - Disperse a binary into shares. Expects as input the binary to be split, the number of shares to be generated (n), the share size (reconstruction threshold) m, and the integer message ID (used to identify shares of the same message). Returns a list of share stricts. SecureIDA.reconstruct/1 - Attempt to reconstruct the original data from a list of share structs generated by the SecureIDA.disperse/4 function. Unlike RabinIDA, this function handles being given more messages than the recontruction threshold. If successful, it returns {:ok, binary} where binary is the original data. If unsuccessful, it returns {:error, string}, where the string contains an error message. iex(1)&gt; shares = SecureIDA . disperse ( &quot;A secure dispersal message&quot; , 4 , 3 , 1234567 ) [ % Share { message_id : 1234567 , total_shares : 4 , share_idx : 1 , share_threshold : 3 , key_share : % KeyShare { aes_key : &lt;&lt; ... &gt;&gt; , iv : &lt;&lt; ... &gt;&gt; } , data : &lt;&lt; ... &gt;&gt; } , ... ] iex(2)&gt; SecureIDA . reconstruct ( shares ) { :ok , &quot;A secure dispersal message&quot; } FileIO (Services) The FileIO service is a simple file transfer service which allows users to test out the functionality of the LAP2 network. It is not recommended to be run outside of a docker contained as it has access to the entire filesystem and will happily read and write to any file if instructed to do so and the program has the correct permissions. It cannot be used by itself since it requires on an instance of the LAP2 network node to be running. The following functions are available: FileIO.run_service/1 - Starts the FileIO service. Expects as input the name of the master GenServer process, however it is advisable to call it using NetUtils.run_fileio/1 , which expects the network address of the host node and resolves the master process name automatically. This function will return {:ok, service_id} if successful, where service_id is the name of the service process. If unsuccessful, it will return {:error, reason}. FileIO.request_file/5 - Requests a file from an introduction point in the network and writes it to the filesystem. Expects a list of network addresses of the introduction points to use, the name of the remote service process, the name of the remote file, the save location on the local filesystem and the name of the local FileIO service process. The function will return :ok or :error based on the initial attempt to send the requests and then write to the filesystem if the retrieval was successful. FileIO.stop_service/1 - Stops the FileIO service. Expects as input the name of the service process, which is returned by FileIO.run_service/1 . This function will return :ok if successful, or {:error, reason} if unsuccessful. Note: The FileIO service is not designed to be used by itself. Code examples can be found in the File Transfer Example .","ref":"readme.html#usage","title":"LAP2 - Usage","type":"extras"},{"doc":"The following tasks are planned for the LAP2 project: General [x] Unit testing [x] Docker build [x] Error logging [x] Command Line Interface [x] Configuration file parsing Networking [x] Efficient UDP datagram buffering and handling [x] UDP socket wrapper [x] TCP socket wrapper [x] ProtoBuff serialisation/deserialisation [x] Peer connection and discovery [x] Distributed hash table [x] Clove storage and relay [x] Introduction Points [x] Proxy routing [x] Connection supervisor module Garlic Cast [x] Rabin's IDA [x] Security Enhanced IDA [x] Proxy discovery Crypto [x] Cryptographic primitives NIF [x] Claimable Ring Signature scheme [x] RSDAKE [x] RSDAKE - Claimability [x] Key exchange Math [x] Matrix module [x] Matrix NIF Bonus [ ] Add function argument descriptions to docs [ ] Add proxy heartbeat [ ] Refactor registry_table as ETS [ ] Sybil guard [ ] Rewrite matrix NIF module in Rust [ ] Contribution verification [ ] Removing bad nodes [ ] Phoenix frontend","ref":"readme.html#task-list","title":"LAP2 - Task List","type":"extras"}]